{"version":3,"file":"afterAttach-d5wtuHZb.js","sources":["../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/util.js","../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/fetchChains.js","../node_modules/@jbrowse/plugin-arc/esm/LinearPairedArcDisplay/afterAttach.js"],"sourcesContent":["import { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\nimport { addDisposer, isAlive } from 'mobx-state-tree';\nimport { autorun } from 'mobx';\n// get tag from BAM or CRAM feature, where CRAM uses feature.get('tags') and\n// BAM does not\nexport function getTag(feature, tag) {\n    const tags = feature.get('tags');\n    return tags !== undefined ? tags[tag] : feature.get(tag);\n}\n// use fallback alt tag, used in situations where upper case/lower case tags\n// exist e.g. Mm/MM for base modifications\nexport function getTagAlt(feature, tag, alt) {\n    var _a;\n    return (_a = getTag(feature, tag)) !== null && _a !== void 0 ? _a : getTag(feature, alt);\n}\n// orientation definitions from igv.js, see also\n// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\nexport const orientationTypes = {\n    fr: {\n        F1R2: 'LR',\n        F2R1: 'LR',\n        F1F2: 'LL',\n        F2F1: 'LL',\n        R1R2: 'RR',\n        R2R1: 'RR',\n        R1F2: 'RL',\n        R2F1: 'RL',\n    },\n    rf: {\n        R1F2: 'LR',\n        R2F1: 'LR',\n        R1R2: 'LL',\n        R2R1: 'LL',\n        F1F2: 'RR',\n        F2F1: 'RR',\n        F1R2: 'RL',\n        F2R1: 'RL',\n    },\n    ff: {\n        F2F1: 'LR',\n        R1R2: 'LR',\n        F2R1: 'LL',\n        R1F2: 'LL',\n        R2F1: 'RR',\n        F1R2: 'RR',\n        R2R1: 'RL',\n        F1F2: 'RL',\n    },\n};\nexport const pairMap = {\n    LR: 'color_pair_lr',\n    LL: 'color_pair_ll',\n    RR: 'color_pair_rr',\n    RL: 'color_pair_rl',\n};\nexport function getColorWGBS(strand, base) {\n    if (strand === 1) {\n        if (base === 'C') {\n            return '#f00';\n        }\n        if (base === 'T') {\n            return '#00f';\n        }\n    }\n    else if (strand === -1) {\n        if (base === 'G') {\n            return '#f00';\n        }\n        if (base === 'A') {\n            return '#00f';\n        }\n    }\n    return '#888';\n}\n// fetches region sequence augmenting by +/- 1bp for CpG on either side of\n// requested region\nexport async function fetchSequence(region, adapter) {\n    var _a;\n    const { start, end, originalRefName, refName } = region;\n    const feats = await firstValueFrom(adapter\n        .getFeatures({\n        ...region,\n        refName: originalRefName || refName,\n        end: end + 1,\n        start: Math.max(0, start - 1),\n    })\n        .pipe(toArray()));\n    return (_a = feats[0]) === null || _a === void 0 ? void 0 : _a.get('seq');\n}\n// has to check underlying C-G (aka CpG) on the reference sequence\nexport function shouldFetchReferenceSequence(type) {\n    return type === 'methylation';\n}\n// adapted from IGV\n// https://github.com/igvteam/igv/blob/e803e3af2d8c9ea049961dfd4628146bdde9a574/src/main/java/org/broad/igv/sam/mods/BaseModificationColors.java#L27\nexport const modificationColors = {\n    m: 'rgb(255,0,0)',\n    h: 'rgb(11, 132, 165)',\n    o: 'rgb(111, 78, 129)',\n    f: 'rgb(246, 200, 95)',\n    c: 'rgb(157, 216, 102)',\n    g: 'rgb(255, 160, 86)',\n    e: 'rgb(141, 221, 208)',\n    b: 'rgb(202, 71, 47)',\n};\nexport function createAutorun(self, cb, opts) {\n    addDisposer(self, autorun(async () => {\n        try {\n            await cb();\n        }\n        catch (e) {\n            if (isAlive(self)) {\n                self.setError(e);\n            }\n        }\n    }, opts));\n}\nexport function randomColor() {\n    return `hsl(${Math.random() * 200}, 50%, 50%)`;\n}\n","import { dedupe, getContainingTrack, getContainingView, getSession, } from '@jbrowse/core/util';\nexport async function fetchChains(self) {\n    // @ts-expect-error\n    const { rpcSessionId: sessionId } = getContainingTrack(self);\n    const { rpcManager } = getSession(self);\n    const view = getContainingView(self);\n    if (!view.initialized || self.error || self.regionTooLarge) {\n        return;\n    }\n    self.setLoading(true);\n    const ret = (await rpcManager.call(sessionId, 'CoreGetFeatures', {\n        sessionId,\n        regions: view.staticBlocks.contentBlocks,\n        adapterConfig: self.adapterConfig,\n    }));\n    self.setFeatures(dedupe(ret, r => r.id()));\n    self.setLoading(false);\n}\n","import { createAutorun } from './util';\nimport { fetchChains } from './fetchChains';\nexport function doAfterAttach(self) {\n    createAutorun(self, async () => {\n        await fetchChains(self);\n    }, { delay: 1000 });\n}\n"],"names":["createAutorun","self","cb","opts","addDisposer","autorun","e","isAlive","fetchChains","sessionId","getContainingTrack","rpcManager","getSession","view","getContainingView","ret","dedupe","r","doAfterAttach"],"mappings":"oEA0GO,SAASA,EAAcC,EAAMC,EAAIC,EAAM,CAC1CC,EAAYH,EAAMI,EAAQ,SAAY,CAClC,GAAI,CACA,MAAMH,EAAI,CACtB,OACeI,EAAG,CACFC,EAAQN,CAAI,GACZA,EAAK,SAASK,CAAC,CAE/B,CACK,EAAEH,CAAI,CAAC,CACZ,CCpHO,eAAeK,EAAYP,EAAM,CAEpC,KAAM,CAAE,aAAcQ,GAAcC,EAAAA,mBAAmBT,CAAI,EACrD,CAAE,WAAAU,CAAU,EAAKC,EAAU,WAACX,CAAI,EAChCY,EAAOC,EAAiB,kBAACb,CAAI,EACnC,GAAI,CAACY,EAAK,aAAeZ,EAAK,OAASA,EAAK,eACxC,OAEJA,EAAK,WAAW,EAAI,EACpB,MAAMc,EAAO,MAAMJ,EAAW,KAAKF,EAAW,kBAAmB,CAC7D,UAAAA,EACA,QAASI,EAAK,aAAa,cAC3B,cAAeZ,EAAK,aAC5B,CAAK,EACDA,EAAK,YAAYe,SAAOD,EAAKE,GAAKA,EAAE,GAAE,CAAE,CAAC,EACzChB,EAAK,WAAW,EAAK,CACzB,CCfO,SAASiB,EAAcjB,EAAM,CAChCD,EAAcC,EAAM,SAAY,CAC5B,MAAMO,EAAYP,CAAI,CAC9B,EAAO,CAAE,MAAO,IAAM,CACtB","x_google_ignoreList":[0,1,2]}