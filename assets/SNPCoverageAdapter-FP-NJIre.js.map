{"version":3,"file":"SNPCoverageAdapter-FP-NJIre.js","sources":["../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/generateCoverageBins.js","../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/SNPCoverageAdapter.js"],"sourcesContent":["import { getTag, getTagAlt, shouldFetchReferenceSequence } from '../util';\nimport { parseCigar, getNextRefPos, getModificationPositions, getMethBins, } from '../MismatchParser';\nimport { doesIntersect2 } from '@jbrowse/core/util';\nfunction mismatchLen(mismatch) {\n    return !isInterbase(mismatch.type) ? mismatch.length : 1;\n}\nfunction isInterbase(type) {\n    return type === 'softclip' || type === 'hardclip' || type === 'insertion';\n}\nfunction inc(bin, strand, type, field) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            total: 0,\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.total++;\n    thisBin[strand]++;\n}\nexport default async function generateCoverageBins(features, region, opts, fetchSequence) {\n    var _a, _b, _c;\n    const { colorBy } = opts;\n    const extendedRegion = {\n        ...region,\n        start: Math.max(0, region.start - 1),\n        end: region.end + 1,\n    };\n    const binMax = Math.ceil(extendedRegion.end - extendedRegion.start);\n    const skipmap = {};\n    const regionSequence = features.length && shouldFetchReferenceSequence((_a = opts.colorBy) === null || _a === void 0 ? void 0 : _a.type)\n        ? await fetchSequence(region)\n        : undefined;\n    const bins = [];\n    for (const feature of features) {\n        const fstart = feature.get('start');\n        const fend = feature.get('end');\n        const fstrand = feature.get('strand');\n        const mismatches = feature.get('mismatches') || [];\n        for (let j = fstart; j < fend + 1; j++) {\n            const i = j - region.start;\n            if (i >= 0 && i < binMax) {\n                if (bins[i] === undefined) {\n                    bins[i] = {\n                        total: 0,\n                        all: 0,\n                        ref: 0,\n                        '-1': 0,\n                        '0': 0,\n                        '1': 0,\n                        lowqual: {},\n                        cov: {},\n                        delskips: {},\n                        noncov: {},\n                    };\n                }\n                if (j !== fend) {\n                    bins[i].total++;\n                    bins[i].all++;\n                    bins[i].ref++;\n                    bins[i][fstrand]++;\n                }\n            }\n        }\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {\n            const seq = feature.get('seq');\n            const mm = getTagAlt(feature, 'MM', 'Mm') || '';\n            const ops = parseCigar(feature.get('CIGAR'));\n            const fend = feature.get('end');\n            if (seq) {\n                const modifications = getModificationPositions(mm, seq, fstrand);\n                for (const { type, positions } of modifications) {\n                    const mod = `mod_${type}`;\n                    for (const pos of getNextRefPos(ops, positions)) {\n                        const epos = pos + fstart - region.start;\n                        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n                            if (bins[epos] === undefined) {\n                                bins[epos] = {\n                                    total: 0,\n                                    all: 0,\n                                    ref: 0,\n                                    '-1': 0,\n                                    '0': 0,\n                                    '1': 0,\n                                    lowqual: {},\n                                    cov: {},\n                                    delskips: {},\n                                    noncov: {},\n                                };\n                            }\n                            const bin = bins[epos];\n                            inc(bin, fstrand, 'cov', mod);\n                        }\n                    }\n                }\n            }\n        }\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {\n            if (!regionSequence) {\n                throw new Error('no region sequence detected, need sequenceAdapter configuration');\n            }\n            const seq = feature.get('seq');\n            if (!seq) {\n                continue;\n            }\n            const { methBins, methProbs } = getMethBins(feature);\n            const dels = mismatches.filter(f => f.type === 'deletion');\n            // methylation based coloring takes into account both reference sequence\n            // CpG detection and reads\n            for (let i = 0; i < fend - fstart; i++) {\n                const j = i + fstart;\n                const l1 = (_b = regionSequence[j - region.start + 1]) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n                const l2 = (_c = regionSequence[j - region.start + 2]) === null || _c === void 0 ? void 0 : _c.toLowerCase();\n                if (l1 === 'c' && l2 === 'g') {\n                    const bin0 = bins[j - region.start];\n                    const bin1 = bins[j - region.start + 1];\n                    const b0 = methBins[i];\n                    const b1 = methBins[i + 1];\n                    const p0 = methProbs[i];\n                    const p1 = methProbs[i + 1];\n                    // color\n                    if ((b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n                        (b1 && (p1 !== undefined ? p1 > 0.5 : true))) {\n                        if (bin0) {\n                            inc(bin0, fstrand, 'cov', 'meth');\n                            bin0.ref--;\n                            bin0[fstrand]--;\n                        }\n                        if (bin1) {\n                            inc(bin1, fstrand, 'cov', 'meth');\n                            bin1.ref--;\n                            bin1[fstrand]--;\n                        }\n                    }\n                    else {\n                        if (bin0) {\n                            if (!dels.some(d => doesIntersect2(j, j + 1, d.start + fstart, d.start + fstart + d.length))) {\n                                inc(bin0, fstrand, 'cov', 'unmeth');\n                                bin0.ref--;\n                                bin0[fstrand]--;\n                            }\n                        }\n                        if (bin1) {\n                            if (!dels.some(d => doesIntersect2(j + 1, j + 2, d.start + fstart, d.start + fstart + d.length))) {\n                                inc(bin1, fstrand, 'cov', 'unmeth');\n                                bin1.ref--;\n                                bin1[fstrand]--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // normal SNP based coloring\n        const colorSNPs = (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'modifications' && (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) !== 'methylation';\n        for (const mismatch of mismatches) {\n            const mstart = fstart + mismatch.start;\n            const mlen = mismatchLen(mismatch);\n            const mend = mstart + mlen;\n            for (let j = mstart; j < mstart + mlen; j++) {\n                const epos = j - region.start;\n                if (epos >= 0 && epos < bins.length) {\n                    const bin = bins[epos];\n                    const { base, type } = mismatch;\n                    const interbase = isInterbase(type);\n                    if (!interbase) {\n                        bin.ref--;\n                        bin[fstrand]--;\n                    }\n                    else {\n                        inc(bin, fstrand, 'noncov', type);\n                    }\n                    if (type === 'deletion' || type === 'skip') {\n                        inc(bin, fstrand, 'delskips', type);\n                        bin.total--;\n                    }\n                    else if (!interbase && colorSNPs) {\n                        inc(bin, fstrand, 'cov', base);\n                        bin.refbase = mismatch.altbase;\n                    }\n                }\n            }\n            if (mismatch.type === 'skip') {\n                const hash = `${mstart}_${mend}_${fstrand}`;\n                if (skipmap[hash] === undefined) {\n                    skipmap[hash] = {\n                        feature: feature,\n                        start: mstart,\n                        end: mend,\n                        strand: fstrand,\n                        xs: getTag(feature, 'XS') || getTag(feature, 'TS'),\n                        score: 0,\n                    };\n                }\n                skipmap[hash].score++;\n            }\n        }\n    }\n    return { bins, skipmap };\n}\n","import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\n// locals\nimport generateCoverageBins from './generateCoverageBins';\nimport { fetchSequence } from '../util';\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n    async configure() {\n        var _a, _b;\n        const subadapterConfig = this.getConf('subadapter');\n        const sequenceConf = subadapterConfig.sequenceAdapter;\n        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));\n        const sequenceAdapter = sequenceConf\n            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))\n            : undefined;\n        if (!dataAdapter) {\n            throw new Error('Failed to get subadapter');\n        }\n        return {\n            subadapter: dataAdapter.dataAdapter,\n            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,\n        };\n    }\n    async fetchSequence(region) {\n        const { sequenceAdapter } = await this.configure();\n        if (!sequenceAdapter) {\n            return undefined;\n        }\n        return fetchSequence(region, sequenceAdapter);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { subadapter } = await this.configure();\n            const feats = await firstValueFrom(subadapter.getFeatures(region, opts).pipe(toArray()));\n            const { bins, skipmap } = await generateCoverageBins(feats, region, opts, arg => this.fetchSequence(arg));\n            bins.forEach((bin, index) => {\n                const start = region.start + index;\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${start}`,\n                    data: {\n                        score: bin.total,\n                        snpinfo: bin,\n                        start,\n                        end: start + 1,\n                        refName: region.refName,\n                    },\n                }));\n            });\n            // make fake features from the coverage\n            Object.entries(skipmap).forEach(([key, skip]) => {\n                observer.next(new SimpleFeature({\n                    id: key,\n                    data: {\n                        type: 'skip',\n                        start: skip.start,\n                        end: skip.end,\n                        strand: skip.strand,\n                        score: skip.score,\n                        xs: skip.xs,\n                    },\n                }));\n            });\n            observer.complete();\n        }, opts.signal);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { subadapter } = await this.configure();\n        return subadapter.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    async getRefNames(opts = {}) {\n        const { subadapter } = await this.configure();\n        return subadapter.getRefNames(opts);\n    }\n    freeResources( /* { region } */) { }\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","inc","bin","strand","field","thisBin","generateCoverageBins","features","region","opts","fetchSequence","_a","_b","_c","colorBy","extendedRegion","binMax","skipmap","regionSequence","shouldFetchReferenceSequence","bins","feature","fstart","fend","fstrand","mismatches","j","i","seq","mm","getTagAlt","ops","parseCigar","modifications","getModificationPositions","positions","mod","pos","getNextRefPos","epos","methBins","methProbs","getMethBins","dels","f","l1","l2","bin0","bin1","b0","b1","p0","p1","d","doesIntersect2","colorSNPs","mstart","mlen","mend","base","interbase","hash","getTag","SNPCoverageAdapter","BaseFeatureDataAdapter","subadapterConfig","sequenceConf","dataAdapter","sequenceAdapter","ObservableCreate","observer","subadapter","feats","firstValueFrom","toArray","arg","index","start","SimpleFeature","key","skip","regions"],"mappings":"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","x_google_ignoreList":[0,1]}