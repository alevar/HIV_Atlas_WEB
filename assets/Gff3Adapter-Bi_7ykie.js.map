{"version":3,"file":"Gff3Adapter-Bi_7ykie.js","sources":["../../node_modules/@jbrowse/plugin-gff3/esm/Gff3Adapter/Gff3Adapter.js"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport { parseStringSync } from 'gff-nostream';\nimport { isGzip, updateStatus } from '@jbrowse/core/util';\nimport { featureData } from '../featureData';\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async loadDataP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const buf = (await openLocation(this.getConf('gffLocation'), this.pluginManager).readFile(opts));\n        const buffer = isGzip(buf)\n            ? await updateStatus('Unzipping', statusCallback, () => unzip(buf))\n            : buf;\n        const headerLines = [];\n        const featureMap = {};\n        let blockStart = 0;\n        const decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n        let i = 0;\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf('\\n', blockStart);\n            // could be a non-newline ended file, so subarray to end of file if n===-1\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = ((decoder === null || decoder === void 0 ? void 0 : decoder.decode(b)) || b.toString()).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else if (line.startsWith('>')) {\n                    break;\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = '';\n                    }\n                    featureMap[refName] += `${line}\\n`;\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${Math.floor(blockStart / 1000000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1000000).toLocaleString('en-US')} MB`);\n            }\n            blockStart = n + 1;\n        }\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing GFF data');\n                    const intervalTree = new IntervalTree();\n                    parseStringSync(lines)\n                        .flat()\n                        .map((f, i) => new SimpleFeature({\n                        data: featureData(f),\n                        id: `${this.id}-${refName}-${i}`,\n                    }))\n                        .forEach(obj => intervalTree.insert([obj.get('start'), obj.get('end')], obj));\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header: headerLines.join('\\n'),\n            intervalTreeMap,\n        };\n    }\n    async loadData(opts) {\n        if (!this.gffFeatures) {\n            this.gffFeatures = this.loadDataP(opts).catch((e) => {\n                this.gffFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.gffFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { intervalTreeMap } = await this.loadData(opts);\n        return Object.keys(intervalTreeMap);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = query;\n                const { intervalTreeMap } = await this.loadData(opts);\n                (_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([start, end]).forEach(f => {\n                    observer.next(f);\n                });\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    freeResources( /* { region } */) { }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","opts","statusCallback","buf","openLocation","buffer","isGzip","updateStatus","unzip","headerLines","featureMap","blockStart","decoder","i","b","line","ret","refName","intervalTreeMap","lines","sc","intervalTree","IntervalTree","parseStringSync","f","SimpleFeature","featureData","obj","e","header","query","ObservableCreate","observer","_a","start","end"],"mappings":"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","x_google_ignoreList":[0]}