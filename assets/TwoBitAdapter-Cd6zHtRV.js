import{aN as x,ay as g,I as _,l as q,Q as S,O,J as C}from"./index-Cb9Tbun5.js";const I=BigInt(32);function D(c,e,t){const n=+!!t,o=+!t;return BigInt(c.getInt32(e,t)*o+c.getInt32(e+4,t)*n)<<I|BigInt(c.getUint32(e,t)*n+c.getUint32(e+4,t)*o)}function M(c,e,t){const n=c.getUint32(e,t),o=c.getUint32(e+4,t),i=+!!t,s=+!t;return BigInt(n*s+o*i)<<I|BigInt(n*i+o*s)}"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(c,e){return D(this,c,e)});"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(c,e){return M(this,c,e)});const z=440477507;function U(c,e){const t=c.prototype[e],n=`_memo_${e}`;c.prototype[e]=function(){return n in this||(this[n]=t.call(this)),this[n]}}const b=["T","C","A","G"],B=[];for(let c=0;c<256;c++)B.push(b[c>>6&3]+b[c>>4&3]+b[c>>2&3]+b[c&3]);const L=B.map(c=>c.toLowerCase());class m{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else if(t)this.filehandle=new x(t);else throw new Error("must supply path or filehandle")}async _detectEndianness(){const e=await this.filehandle.read(g.Buffer.allocUnsafe(8),0,8,0),{buffer:t}=e;if(t.readInt32LE(0)===z)this.version=t.readInt32LE(4);else throw t.readInt32BE(0)===z?new Error("big endian not supported"):new Error("not a 2bit file")}async getHeader(){await this._detectEndianness();const{buffer:e}=await this.filehandle.read(g.Buffer.allocUnsafe(16),0,16,0),t=e,n=!0,o=new DataView(t.buffer,t.byteOffset,t.length);let i=0;const s=o.getInt32(i,n);if(i+=4,s!==440477507)throw new Error(`Wrong magic number ${s}`);const a=o.getInt32(i,n);i+=4;const r=o.getUint32(i,n);i+=4;const u=o.getUint32(i,n);return{version:a,magic:s,sequenceCount:r,reserved:u}}async getIndex(){const e=await this.getHeader(),t=8+e.sequenceCount*(257+(this.version===1?8:4)),{buffer:n}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,8),o=!0,i=n,s=new DataView(i.buffer,i.byteOffset,i.length);let a=0;const r=s.getUint32(a,o);a+=4,a+=4;const u=[];for(let d=0;d<r;d++){const h=s.getUint8(a);a+=1;const l=n.subarray(a,a+h).toString();if(a+=h,e.version===1){const f=Number(s.getBigUint64(a,o));a+=8,u.push({offset:f,name:l})}else{const f=s.getUint32(a,o);a+=4,u.push({offset:f,name:l})}}return Object.fromEntries(u.map(({name:d,offset:h})=>[d,h]))}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),n=Object.values(e).map(s=>this._getSequenceSize(s)),o=await Promise.all(n),i={};for(const[s,a]of t.entries())i[a]=o[s];return i}async getSequenceSize(e){const n=(await this.getIndex())[e];if(n)return this._getSequenceSize(n)}async _getSequenceSize(e){return this._record1(e).then(t=>t.dnaSize)}async _record1(e,t=8){const{buffer:n}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=n,i=!0;let s=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(s,i);s+=4;const u=a.getUint32(s,i);return s+=4,{dnaSize:r,nBlockCount:u}}async _record2(e,t){const{buffer:n}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=n,i=!0;let s=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(s,i);s+=4;const u=[];for(let l=0;l<r;l++){const f=a.getUint32(s,i);s+=4,u.push(f)}const d=[];for(let l=0;l<r;l++){const f=a.getUint32(s,i);s+=4,d.push(f)}return{maskBlockCount:a.getUint32(s,i),nBlockSizes:d,nBlockStarts:u}}async _record3(e,t){const{buffer:n}=await this.filehandle.read(g.Buffer.allocUnsafe(t),0,t,e),o=n,i=!0;let s=0;const a=new DataView(o.buffer,o.byteOffset,o.length),r=a.getUint32(s,i);s+=4;const u=[];for(let l=0;l<r;l++){const f=a.getUint32(s,i);s+=4,u.push(f)}const d=[];for(let l=0;l<r;l++){const f=a.getUint32(s,i);s+=4,d.push(f)}const h=a.getInt32(s,i);return{maskBlockCount:r,maskBlockSizes:d,maskBlockStarts:u,reserved:h}}async _getSequenceRecord(e){const t=await this._record1(e),n=t.nBlockCount*8+8,o=await this._record2(e+4,n),i=o.maskBlockCount*8+8,s=await this._record3(e+4+n-4,i);return{dnaSize:t.dnaSize,nBlocks:{starts:o.nBlockStarts,sizes:o.nBlockSizes},maskBlocks:{starts:s.maskBlockStarts,sizes:s.maskBlockSizes},dnaPosition:e+4+n-4+i}}async getSequence(e,t=0,n=Number.POSITIVE_INFINITY){const i=(await this.getIndex())[e];if(!i)return;const s=await this._getSequenceRecord(i);if(t<0)throw new TypeError("regionStart cannot be less than 0");(n===void 0||n>s.dnaSize)&&(n=s.dnaSize);const a=this._getOverlappingBlocks(t,n,s.nBlocks.starts,s.nBlocks.sizes),r=this._getOverlappingBlocks(t,n,s.maskBlocks.starts,s.maskBlocks.sizes),u=g.Buffer.allocUnsafe(Math.ceil((n-t)/4)+1),d=Math.floor(t/4),{buffer:h}=await this.filehandle.read(u,0,u.length,s.dnaPosition+d);let l="";for(let f=t;f<n;f+=1){for(;r.length>0&&r[0].end<=f;)r.shift();const k=r[0]&&r[0].start<=f&&r[0].end>f;if(a[0]&&f>=a[0].start&&f<a[0].end){const w=a.shift();for(;f<w.end&&f<n;f+=1)l+=k?"n":"N";f-=1}else{const w=Math.floor(f/4)-d,p=f%4,y=h[w];l+=k?L[y][p]:B[y][p]}}return l}_getOverlappingBlocks(e,t,n,o){let i,s;for(const[r,u]of n.entries()){const d=o[r];if(e>=u+d||t<=u){if(i!==void 0){s=r;break}}else i===void 0&&(i=r)}if(i===void 0)return[];s===void 0&&(s=n.length);const a=new Array(s-i);for(let r=i;r<s;r+=1)a[r-i]={start:n[r],end:n[r]+o[r],size:o[r]};return a}}U(m,"getIndex");U(m,"getHeader");class $ extends _.BaseSequenceAdapter{async initChromSizes(){const e=q.readConfObject(this.config,"chromSizesLocation");if(e.uri!=="/path/to/default.chrom.sizes"&&e.uri!==""){const n=await S.openLocation(e,this.pluginManager).readFile("utf8");return Object.fromEntries(n.split(/\n|\r\n|\r/).filter(o=>!!o.trim()).map(o=>{const[i,s]=o.split("	");return[i,+s]}))}}constructor(e,t,n){super(e,t,n);const o=this.pluginManager;this.chromSizesData=this.initChromSizes(),this.twobit=new m({filehandle:S.openLocation(this.getConf("twoBitLocation"),o)})}async getRefNames(){const e=await this.chromSizesData;return e?Object.keys(e):this.twobit.getSequenceNames()}async getRegions(){const e=await this.chromSizesData;if(e)return Object.keys(e).map(n=>({refName:n,start:0,end:e[n]}));const t=await this.twobit.getSequenceSizes();return Object.keys(t).map(n=>({refName:n,start:0,end:t[n]}))}getFeatures({refName:e,start:t,end:n}){return O(async o=>{const i=await this.twobit.getSequenceSize(e),s=i!==void 0?Math.min(i,n):n,a=await this.twobit.getSequence(e,t,s);a&&o.next(new C({id:`${e} ${t}-${s}`,data:{refName:e,start:t,end:s,seq:a}})),o.complete()})}freeResources(){}}export{$ as default};
//# sourceMappingURL=TwoBitAdapter-Cd6zHtRV.js.map
