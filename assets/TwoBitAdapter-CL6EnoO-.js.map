{"version":3,"file":"TwoBitAdapter-CL6EnoO-.js","sources":["../../node_modules/@gmod/twobit/esm/bigint-polyfill/pure.js","../../node_modules/@gmod/twobit/esm/bigint-polyfill/polyfill.js","../../node_modules/@gmod/twobit/esm/twoBitFile.js","../../node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js"],"sourcesContent":["const BigInt32 = BigInt(32);\nexport function getBigInt64(dataView, byteOffset, littleEndian) {\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    return ((BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) <<\n        BigInt32) |\n        BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n            dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask));\n}\nexport function getBigUint64(dataView, byteOffset, littleEndian) {\n    const a = dataView.getUint32(byteOffset, littleEndian);\n    const b = dataView.getUint32(byteOffset + 4, littleEndian);\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    // This branch-less optimization is 77x faster than normal ternary operator.\n    // and only 3% slower than native implementation\n    // https://jsbench.me/p8kyhg1eqv/1\n    return ((BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n        BigInt(a * littleEndianMask + b * bigEndianMask));\n}\n//# sourceMappingURL=pure.js.map","import { getBigInt64, getBigUint64 } from './pure';\nif (!('getBigInt64' in DataView)) {\n    DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n        return getBigInt64(this, byteOffset, littleEndian);\n    };\n}\nif (!('getBigUint64' in DataView)) {\n    DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        return getBigUint64(this, byteOffset, littleEndian);\n    };\n}\n//# sourceMappingURL=polyfill.js.map","import { LocalFile } from 'generic-filehandle';\nimport { Buffer } from 'buffer';\nconst TWOBIT_MAGIC = 0x1a412743;\nfunction tinyMemoize(_class, methodName) {\n    const method = _class.prototype[methodName];\n    const memoAttributeName = `_memo_${methodName}`;\n    _class.prototype[methodName] = function _tinyMemoized() {\n        if (!(memoAttributeName in this)) {\n            this[memoAttributeName] = method.call(this);\n        }\n        return this[memoAttributeName];\n    };\n}\nconst twoBit = ['T', 'C', 'A', 'G'];\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [];\nfor (let index = 0; index < 256; index++) {\n    byteTo4Bases.push(twoBit[(index >> 6) & 3] +\n        twoBit[(index >> 4) & 3] +\n        twoBit[(index >> 2) & 3] +\n        twoBit[index & 3]);\n}\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase());\nexport default class TwoBitFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path] filesystem path for the .2bit file to open\n     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n     *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n     */\n    constructor({ filehandle, path, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new Error('must supply path or filehandle');\n        }\n    }\n    async _detectEndianness() {\n        const returnValue = await this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0);\n        const { buffer } = returnValue;\n        if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {\n            this.version = buffer.readInt32LE(4);\n        }\n        else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {\n            throw new Error('big endian not supported');\n        }\n        else {\n            throw new Error('not a 2bit file');\n        }\n    }\n    // memoize\n    /**\n     * @returns {Promise} for object with the file's header information, like\n     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`\n     */\n    async getHeader() {\n        await this._detectEndianness();\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0);\n        const b = buffer;\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const magic = dataView.getInt32(offset, le);\n        offset += 4;\n        if (magic !== 0x1a412743) {\n            throw new Error(`Wrong magic number ${magic}`);\n        }\n        const version = dataView.getInt32(offset, le);\n        offset += 4;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const reserved = dataView.getUint32(offset, le);\n        return { version, magic, sequenceCount, reserved };\n    }\n    // memoize\n    /**\n     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`\n     */\n    async getIndex() {\n        const header = await this.getHeader();\n        const maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8);\n        const le = true;\n        const b = buffer;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        // const reserved = dataView.getUint32(offset, le)\n        offset += 4;\n        const indexData = [];\n        for (let i = 0; i < sequenceCount; i++) {\n            const nameLength = dataView.getUint8(offset);\n            offset += 1;\n            const name = buffer.subarray(offset, offset + nameLength).toString();\n            offset += nameLength;\n            if (header.version === 1) {\n                const dataOffset = Number(dataView.getBigUint64(offset, le));\n                offset += 8;\n                indexData.push({ offset: dataOffset, name });\n            }\n            else {\n                const dataOffset = dataView.getUint32(offset, le);\n                offset += 4;\n                indexData.push({ offset: dataOffset, name });\n            }\n        }\n        return Object.fromEntries(indexData.map(({ name, offset }) => [name, offset]));\n    }\n    /**\n     * @returns {Promise} for an array of string sequence names that are found in the file\n     */\n    async getSequenceNames() {\n        const index = await this.getIndex();\n        return Object.keys(index);\n    }\n    /**\n     * @returns {Promise} for an object listing the lengths of all sequences like\n     * `{seqName: length, ...}`.\n     *\n     * note: this is a relatively slow operation especially if there are many\n     * refseqs in the file, if you can get this information from a different file\n     * e.g. a chrom.sizes file, it will be much faster\n     */\n    async getSequenceSizes() {\n        const index = await this.getIndex();\n        const seqNames = Object.keys(index);\n        const sizePromises = Object.values(index).map(offset => this._getSequenceSize(offset));\n        const sizes = await Promise.all(sizePromises);\n        const returnObject = {};\n        for (const [index_, seqName] of seqNames.entries()) {\n            returnObject[seqName] = sizes[index_];\n        }\n        return returnObject;\n    }\n    /**\n     * @param {string} seqName name of the sequence\n     * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n     */\n    async getSequenceSize(seqName) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        return this._getSequenceSize(offset);\n    }\n    async _getSequenceSize(offset) {\n        return this._record1(offset).then(f => f.dnaSize);\n    }\n    async _record1(offset2, len = 8) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const dnaSize = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        return { dnaSize, nBlockCount };\n    }\n    async _record2(offset2, len) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockStarts = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockStarts.push(elt);\n        }\n        const nBlockSizes = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockSizes.push(elt);\n        }\n        const maskBlockCount = dataView.getUint32(offset, le);\n        return {\n            maskBlockCount,\n            nBlockSizes,\n            nBlockStarts,\n        };\n    }\n    async _record3(offset2, len) {\n        const { buffer } = await this.filehandle.read(Buffer.allocUnsafe(len), 0, len, offset2);\n        const b = buffer;\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const maskBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const maskBlockStarts = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockStarts.push(elt);\n        }\n        const maskBlockSizes = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockSizes.push(elt);\n        }\n        const reserved = dataView.getInt32(offset, le);\n        return {\n            maskBlockCount,\n            maskBlockSizes,\n            maskBlockStarts,\n            reserved,\n        };\n    }\n    async _getSequenceRecord(offset) {\n        const rec1 = await this._record1(offset);\n        const rec2DataLen = rec1.nBlockCount * 8 + 8;\n        const rec2 = await this._record2(offset + 4, rec2DataLen);\n        const rec3DataLen = rec2.maskBlockCount * 8 + 8;\n        const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen);\n        const rec = {\n            dnaSize: rec1.dnaSize,\n            nBlocks: {\n                starts: rec2.nBlockStarts,\n                sizes: rec2.nBlockSizes,\n            },\n            maskBlocks: {\n                starts: rec3.maskBlockStarts,\n                sizes: rec3.maskBlockSizes,\n            },\n            dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n        };\n        return rec;\n    }\n    /**\n     * @param {string} seqName name of the sequence you want\n     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n     * @returns {Promise} for a string of sequence bases\n     */\n    async getSequence(seqName, regionStart = 0, regionEnd = Number.POSITIVE_INFINITY) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        // fetch the record for the seq\n        const record = await this._getSequenceRecord(offset);\n        if (regionStart < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        // end defaults to the end of the sequence\n        if (regionEnd === undefined || regionEnd > record.dnaSize) {\n            regionEnd = record.dnaSize;\n        }\n        const nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);\n        const maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);\n        const baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);\n        const baseBytesOffset = Math.floor(regionStart / 4);\n        const { buffer } = await this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset);\n        let sequenceBases = '';\n        for (let genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {\n            // check whether we are currently masked\n            while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n                maskBlocks.shift();\n            }\n            const baseIsMasked = maskBlocks[0] &&\n                maskBlocks[0].start <= genomicPosition &&\n                maskBlocks[0].end > genomicPosition;\n            // process the N block if we have one\n            if (nBlocks[0] &&\n                genomicPosition >= nBlocks[0].start &&\n                genomicPosition < nBlocks[0].end) {\n                const currentNBlock = nBlocks.shift();\n                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {\n                    sequenceBases += baseIsMasked ? 'n' : 'N';\n                }\n                genomicPosition -= 1;\n            }\n            else {\n                const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;\n                const subPosition = genomicPosition % 4;\n                const byte = buffer[bytePosition];\n                sequenceBases += baseIsMasked\n                    ? maskedByteTo4Bases[byte][subPosition]\n                    : byteTo4Bases[byte][subPosition];\n            }\n        }\n        return sequenceBases;\n    }\n    _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {\n        // find the start and end indexes of the blocks that match\n        let startIndex;\n        let endIndex;\n        for (const [index, blockStart] of blockStarts.entries()) {\n            const blockSize = blockSizes[index];\n            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n                // block does not overlap the region\n                if (startIndex !== undefined) {\n                    endIndex = index;\n                    break;\n                }\n            }\n            else if (startIndex === undefined) {\n                startIndex = index;\n            } // block does overlap the region, record this if it is the first\n        }\n        if (startIndex === undefined) {\n            return [];\n        }\n        // now format some block objects to return\n        if (endIndex === undefined) {\n            endIndex = blockStarts.length;\n        }\n        const blocks = new Array(endIndex - startIndex);\n        for (let blockNumber = startIndex; blockNumber < endIndex; blockNumber += 1) {\n            blocks[blockNumber - startIndex] = {\n                start: blockStarts[blockNumber],\n                end: blockStarts[blockNumber] + blockSizes[blockNumber],\n                size: blockSizes[blockNumber],\n            };\n        }\n        return blocks;\n    }\n}\ntinyMemoize(TwoBitFile, 'getIndex');\ntinyMemoize(TwoBitFile, 'getHeader');\n//# sourceMappingURL=twoBitFile.js.map","import { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { TwoBitFile } from '@gmod/twobit';\nimport { readConfObject } from '@jbrowse/core/configuration';\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n    async initChromSizes() {\n        const conf = readConfObject(this.config, 'chromSizesLocation');\n        // check against default and empty in case someone makes the field blank in\n        // config editor, may want better way to check \"optional config slots\" in\n        // future\n        if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n            const file = openLocation(conf, this.pluginManager);\n            const data = await file.readFile('utf8');\n            return Object.fromEntries(data\n                .split(/\\n|\\r\\n|\\r/)\n                .filter(line => !!line.trim())\n                .map(line => {\n                const [name, length] = line.split('\\t');\n                return [name, +length];\n            }));\n        }\n        return undefined;\n    }\n    constructor(config, getSubAdapter, pluginManager) {\n        super(config, getSubAdapter, pluginManager);\n        const pm = this.pluginManager;\n        this.chromSizesData = this.initChromSizes();\n        this.twobit = new TwoBitFile({\n            filehandle: openLocation(this.getConf('twoBitLocation'), pm),\n        });\n    }\n    async getRefNames() {\n        const chromSizesData = await this.chromSizesData;\n        if (chromSizesData) {\n            return Object.keys(chromSizesData);\n        }\n        return this.twobit.getSequenceNames();\n    }\n    async getRegions() {\n        const chromSizesData = await this.chromSizesData;\n        if (chromSizesData) {\n            return Object.keys(chromSizesData).map(refName => ({\n                refName,\n                start: 0,\n                end: chromSizesData[refName],\n            }));\n        }\n        const refSizes = await this.twobit.getSequenceSizes();\n        return Object.keys(refSizes).map(refName => ({\n            refName,\n            start: 0,\n            end: refSizes[refName],\n        }));\n    }\n    /**\n     * Fetch features for a certain region\n     * @param param -\n     * @returns Observable of Feature objects in the region\n     */\n    getFeatures({ refName, start, end }) {\n        return ObservableCreate(async (observer) => {\n            const size = await this.twobit.getSequenceSize(refName);\n            const regionEnd = size !== undefined ? Math.min(size, end) : end;\n            const seq = await this.twobit.getSequence(refName, start, regionEnd);\n            if (seq) {\n                observer.next(new SimpleFeature({\n                    id: `${refName} ${start}-${regionEnd}`,\n                    data: { refName, start, end: regionEnd, seq },\n                }));\n            }\n            observer.complete();\n        });\n    }\n    /**\n     * called to provide a hint that data tied to a certain region\n     * will not be needed for the foreseeable future and can be purged\n     * from caches, etc\n     */\n    freeResources( /* { region } */) { }\n}\n"],"names":["BigInt32","getBigInt64","dataView","byteOffset","littleEndian","littleEndianMask","bigEndianMask","getBigUint64","a","b","TWOBIT_MAGIC","tinyMemoize","_class","methodName","method","memoAttributeName","twoBit","byteTo4Bases","index","maskedByteTo4Bases","bases","TwoBitFile","filehandle","path","LocalFile","returnValue","Buffer","buffer","le","offset","magic","version","sequenceCount","reserved","header","maxIndexLength","indexData","i","nameLength","name","dataOffset","seqNames","sizePromises","sizes","returnObject","index_","seqName","f","offset2","len","dnaSize","nBlockCount","nBlockStarts","elt","nBlockSizes","maskBlockCount","maskBlockStarts","maskBlockSizes","rec1","rec2DataLen","rec2","rec3DataLen","rec3","regionStart","regionEnd","record","nBlocks","maskBlocks","baseBytes","baseBytesOffset","sequenceBases","genomicPosition","baseIsMasked","currentNBlock","bytePosition","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blockSize","blocks","blockNumber","TwoBitAdapter","BaseSequenceAdapter","conf","readConfObject","data","openLocation","line","length","config","getSubAdapter","pluginManager","pm","chromSizesData","refName","refSizes","start","end","ObservableCreate","observer","size","seq","SimpleFeature"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}