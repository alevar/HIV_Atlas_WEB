{"version":3,"file":"VcfAdapter-C8oUcD3l.js","sources":["../node_modules/@jbrowse/plugin-variants/esm/VcfAdapter/VcfAdapter.js"],"sourcesContent":["import { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { updateStatus, isGzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport IntervalTree from '@flatten-js/interval-tree';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport VCF from '@gmod/vcf';\n// local\nimport VcfFeature from '../VcfFeature';\nclass VcfAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async getHeader() {\n        const { header } = await this.setup();\n        return header;\n    }\n    async getMetadata() {\n        const { header } = await this.setup();\n        const parser = new VCF({ header });\n        return parser.getMetadata();\n    }\n    async setupP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const buf = (await openLocation(this.getConf('vcfLocation'), this.pluginManager).readFile(opts));\n        const buffer = isGzip(buf)\n            ? await updateStatus('Unzipping', statusCallback, () => unzip(buf))\n            : buf;\n        const headerLines = [];\n        const featureMap = {};\n        let blockStart = 0;\n        const decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n        let i = 0;\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf('\\n', blockStart);\n            // could be a non-newline ended file, so slice to end of file if n===-1\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = ((decoder === null || decoder === void 0 ? void 0 : decoder.decode(b)) || b.toString()).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = [];\n                    }\n                    featureMap[refName].push(line);\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${Math.floor(blockStart / 1000000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1000000).toLocaleString('en-US')} MB`);\n            }\n            blockStart = n + 1;\n        }\n        const header = headerLines.join('\\n');\n        const parser = new VCF({ header });\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing VCF data');\n                    let idx = 0;\n                    const intervalTree = new IntervalTree();\n                    for (const line of lines) {\n                        const f = new VcfFeature({\n                            variant: parser.parseLine(line),\n                            parser,\n                            id: `${this.id}-${refName}-${idx++}`,\n                        });\n                        intervalTree.insert([f.get('start'), f.get('end')], f);\n                    }\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header,\n            intervalTreeMap,\n        };\n    }\n    async setup() {\n        if (!this.vcfFeatures) {\n            this.vcfFeatures = this.setupP().catch((e) => {\n                this.vcfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.vcfFeatures;\n    }\n    async getRefNames(_ = {}) {\n        const { intervalTreeMap } = await this.setup();\n        return Object.keys(intervalTreeMap);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = region;\n                const { intervalTreeMap } = await this.setup();\n                (_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([start, end]).forEach(f => {\n                    observer.next(f);\n                });\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.signal);\n    }\n    freeResources() { }\n}\nVcfAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default VcfAdapter;\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","header","VCF","opts","statusCallback","buf","openLocation","buffer","isGzip","updateStatus","unzip","headerLines","featureMap","blockStart","decoder","i","n","b","line","ret","refName","parser","intervalTreeMap","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","_","region","ObservableCreate","observer","_a","start","end","e"],"mappings":"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","x_google_ignoreList":[0]}