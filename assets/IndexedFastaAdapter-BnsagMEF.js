import{aN as l,ay as x,I,aI as _,aO as b,Q as d,O as q,u as F}from"./index-DvmOrY9r.js";function S(r,e){return r.offset+r.lineBytes*Math.floor(e/r.lineLength)+e%r.lineLength}async function O(r,e){const t=await r.readFile(e);if(!(t!=null&&t.length))throw new Error("No data read from FASTA index (FAI) file");let a=0,n;const i=t.toString("utf8").split(/\r?\n/).filter(s=>/\S/.test(s)).map(s=>s.split("	")).filter(s=>s[0]!=="").map(s=>((!n||n.name!==s[0])&&(n={name:s[0],id:a},a+=1),{id:n.id,name:s[0],length:+s[1],start:0,end:+s[1],offset:+s[2],lineLength:+s[3],lineBytes:+s[4]}));return{name:Object.fromEntries(i.map(s=>[s.name,s])),id:Object.fromEntries(i.map(s=>[s.id,s]))}}class L{constructor({fasta:e,fai:t,path:a,faiPath:n}){if(e)this.fasta=e;else if(a)this.fasta=new l(a);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(t)this.fai=t;else if(n)this.fai=new l(n);else if(a)this.fai=new l(`${a}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile")}async _getIndexes(e){return this.indexes||(this.indexes=O(this.fai,e)),this.indexes}async getSequenceNames(e){return Object.keys((await this._getIndexes(e)).name)}async getSequenceSizes(e){const t={},a=await this._getIndexes(e);for(const n of Object.values(a.id))t[n.name]=n.length;return t}async getSequenceSize(e,t){var a;return(a=(await this._getIndexes(t)).name[e])===null||a===void 0?void 0:a.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t)).name[e]}async getResiduesById(e,t,a,n){const i=(await this._getIndexes(n)).id[e];if(i)return this._fetchFromIndexEntry(i,t,a,n)}async getResiduesByName(e,t,a,n){const i=(await this._getIndexes(n)).name[e];if(i)return this._fetchFromIndexEntry(i,t,a,n)}async getSequence(e,t,a,n){return this.getResiduesByName(e,t,a,n)}async _fetchFromIndexEntry(e,t=0,a,n){let i=a;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((i===void 0||i>e.length)&&(i=e.length),t>=i)return"";const s=S(e,t),o=S(e,i)-s,u=x.Buffer.allocUnsafe(o);return await this.fasta.read(u,0,o,s,n),u.toString("utf8").replace(/\s+/g,"")}}class N extends I.BaseSequenceAdapter{constructor(){super(...arguments),this.seqCache=new _({cache:new b({maxSize:200}),fill:async(e,t)=>{const{refName:a,start:n,end:i,fasta:s}=e;return s.getSequence(a,n,i,{...e,signal:t})}})}async getRefNames(e){const{fasta:t}=await this.setup();return t.getSequenceNames(e)}async getRegions(e){const{fasta:t}=await this.setup(),a=await t.getSequenceSizes(e);return Object.keys(a).map(n=>({refName:n,start:0,end:a[n]}))}async setupPre(){const e=this.getConf("fastaLocation"),t=this.getConf("faiLocation");return{fasta:new L({fasta:d.openLocation(e,this.pluginManager),fai:d.openLocation(t,this.pluginManager)})}}async getHeader(){const e=this.getConf("metadataLocation");return e.uri===""||e.uri==="/path/to/fa.metadata.yaml"?null:d.openLocation(e,this.pluginManager).readFile("utf8")}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(e=>{throw this.setupP=void 0,e})),this.setupP}getFeatures(e,t){const{refName:a,start:n,end:i}=e;return q(async s=>{const{fasta:o}=await this.setup(),u=await o.getSequenceSize(a,t),h=Math.min(u,i),g=[],c=128e3,m=n-n%c,w=i+(c-i%c);for(let f=m;f<w;f+=c){const y={refName:a,start:f,end:f+c};g.push(this.seqCache.get(JSON.stringify(y),{...y,fasta:o},t==null?void 0:t.signal))}const p=(await Promise.all(g)).join("").slice(n-m).slice(0,i-n);p&&s.next(new F.SimpleFeature({id:`${a} ${n}-${h}`,data:{refName:a,start:n,end:h,seq:p}})),s.complete()})}freeResources(){}}const E=Object.freeze(Object.defineProperty({__proto__:null,default:N},Symbol.toStringTag,{value:"Module"}));export{L as I,N as a,E as b};
//# sourceMappingURL=IndexedFastaAdapter-BnsagMEF.js.map
