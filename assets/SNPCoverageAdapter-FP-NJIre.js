import{af as L,ag as O,ah as T,ai as G,aj as V,ak as X,u as j,al as k,c as z,am as H,O as J,f as K,t as Q,_ as E}from"./rpcWorker-CL9qhe4-.js";function U(l){return P(l.type)?1:l.length}function P(l){return l==="softclip"||l==="hardclip"||l==="insertion"}function A(l,t,e,u){let p=l[e][u];p===void 0&&(p=l[e][u]={total:0,"-1":0,0:0,1:0}),p.total++,p[t]++}async function W(l,t,e,u){var p,q,v;const{colorBy:r}=e,b={...t,start:Math.max(0,t.start-1),end:t.end+1},y=Math.ceil(b.end-b.start),w={},M=l.length&&L((p=e.colorBy)===null||p===void 0?void 0:p.type)?await u(t):void 0,c=[];for(const h of l){const g=h.get("start"),R=h.get("end"),a=h.get("strand"),F=h.get("mismatches")||[];for(let d=g;d<R+1;d++){const s=d-t.start;s>=0&&s<y&&(c[s]===void 0&&(c[s]={total:0,all:0,ref:0,"-1":0,0:0,1:0,lowqual:{},cov:{},delskips:{},noncov:{}}),d!==R&&(c[s].total++,c[s].all++,c[s].ref++,c[s][a]++))}if((r==null?void 0:r.type)==="modifications"){const d=h.get("seq"),s=O(h,"MM","Mm")||"",S=T(h.get("CIGAR")),x=h.get("end");if(d){const n=G(s,d,a);for(const{type:f,positions:m}of n){const C=`mod_${f}`;for(const o of V(S,m)){const i=o+g-t.start;if(i>=0&&i<c.length&&o+g<x){c[i]===void 0&&(c[i]={total:0,all:0,ref:0,"-1":0,0:0,1:0,lowqual:{},cov:{},delskips:{},noncov:{}});const B=c[i];A(B,a,"cov",C)}}}}}if((r==null?void 0:r.type)==="methylation"){if(!M)throw new Error("no region sequence detected, need sequenceAdapter configuration");if(!h.get("seq"))continue;const{methBins:s,methProbs:S}=X(h),x=F.filter(n=>n.type==="deletion");for(let n=0;n<R-g;n++){const f=n+g,m=(q=M[f-t.start+1])===null||q===void 0?void 0:q.toLowerCase(),C=(v=M[f-t.start+2])===null||v===void 0?void 0:v.toLowerCase();if(m==="c"&&C==="g"){const o=c[f-t.start],i=c[f-t.start+1],B=s[n],D=s[n+1],N=S[n],$=S[n+1];B&&(N===void 0||N>.5)||D&&($===void 0||$>.5)?(o&&(A(o,a,"cov","meth"),o.ref--,o[a]--),i&&(A(i,a,"cov","meth"),i.ref--,i[a]--)):(o&&(x.some(_=>j.doesIntersect2(f,f+1,_.start+g,_.start+g+_.length))||(A(o,a,"cov","unmeth"),o.ref--,o[a]--)),i&&(x.some(_=>j.doesIntersect2(f+1,f+2,_.start+g,_.start+g+_.length))||(A(i,a,"cov","unmeth"),i.ref--,i[a]--)))}}}const I=(r==null?void 0:r.type)!=="modifications"&&(r==null?void 0:r.type)!=="methylation";for(const d of F){const s=g+d.start,S=U(d),x=s+S;for(let n=s;n<s+S;n++){const f=n-t.start;if(f>=0&&f<c.length){const m=c[f],{base:C,type:o}=d,i=P(o);i?A(m,a,"noncov",o):(m.ref--,m[a]--),o==="deletion"||o==="skip"?(A(m,a,"delskips",o),m.total--):!i&&I&&(A(m,a,"cov",C),m.refbase=d.altbase)}}if(d.type==="skip"){const n=`${s}_${x}_${a}`;w[n]===void 0&&(w[n]={feature:h,start:s,end:x,strand:a,xs:k(h,"XS")||k(h,"TS"),score:0}),w[n].score++}}}return{bins:c,skipmap:w}}class Z extends z.BaseFeatureDataAdapter{async configure(){var t,e;const u=this.getConf("subadapter"),p=u.sequenceAdapter,q=await((t=this.getSubAdapter)===null||t===void 0?void 0:t.call(this,u)),v=p?await((e=this.getSubAdapter)===null||e===void 0?void 0:e.call(this,p)):void 0;if(!q)throw new Error("Failed to get subadapter");return{subadapter:q.dataAdapter,sequenceAdapter:v==null?void 0:v.dataAdapter}}async fetchSequence(t){const{sequenceAdapter:e}=await this.configure();if(e)return H(t,e)}getFeatures(t,e={}){return J(async u=>{const{subadapter:p}=await this.configure(),q=await K(p.getFeatures(t,e).pipe(Q())),{bins:v,skipmap:r}=await W(q,t,e,b=>this.fetchSequence(b));v.forEach((b,y)=>{const w=t.start+y;u.next(new E({id:`${this.id}-${w}`,data:{score:b.total,snpinfo:b,start:w,end:w+1,refName:t.refName}}))}),Object.entries(r).forEach(([b,y])=>{u.next(new E({id:b,data:{type:"skip",start:y.start,end:y.end,strand:y.strand,score:y.score,xs:y.xs}}))}),u.complete()},e.signal)}async getMultiRegionFeatureDensityStats(t,e){const{subadapter:u}=await this.configure();return u.getMultiRegionFeatureDensityStats(t,e)}async getRefNames(t={}){const{subadapter:e}=await this.configure();return e.getRefNames(t)}freeResources(){}}export{Z as default};
//# sourceMappingURL=SNPCoverageAdapter-FP-NJIre.js.map
