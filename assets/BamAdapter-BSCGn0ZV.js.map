{"version":3,"file":"BamAdapter-BSCGn0ZV.js","sources":["../node_modules/@gmod/bam/esm/virtualOffset.js","../node_modules/@gmod/bam/esm/chunk.js","../node_modules/@gmod/bam/esm/util.js","../node_modules/@gmod/bam/esm/indexFile.js","../node_modules/@gmod/bam/esm/bai.js","../node_modules/@gmod/bam/esm/csi.js","../node_modules/@gmod/bam/esm/constants.js","../node_modules/@gmod/bam/esm/record.js","../node_modules/@gmod/bam/esm/sam.js","../node_modules/@gmod/bam/esm/bamFile.js","../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamSlightlyLazyFeature.js","../node_modules/@jbrowse/plugin-alignments/esm/BamAdapter/BamAdapter.js"],"sourcesContent":["export default class VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n    static min(...args) {\n        let min;\n        let i = 0;\n        for (; !min; i += 1) {\n            min = args[i];\n        }\n        for (; i < args.length; i += 1) {\n            if (min.compareTo(args[i]) > 0) {\n                min = args[i];\n            }\n        }\n        return min;\n    }\n}\nexport function fromBytes(bytes, offset = 0, bigendian = false) {\n    if (bigendian) {\n        throw new Error('big-endian virtual file offsets not implemented');\n    }\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\n//# sourceMappingURL=virtualOffset.js.map","// little class representing a chunk in the index\nexport default class Chunk {\n    constructor(minv, maxv, bin, _fetchedSize) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = _fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv.toString()}..${this.maxv.toString()} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\n//# sourceMappingURL=chunk.js.map","import Long from 'long';\nexport function timeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexport function longToNumber(long) {\n    if (long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n        long.lessThan(Number.MIN_SAFE_INTEGER)) {\n        throw new Error('integer overflow');\n    }\n    return long.toNumber();\n}\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        // console.log('bam aborted!')\n        if (typeof DOMException === 'undefined') {\n            const e = new Error('aborted');\n            //@ts-ignore\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n        else {\n            throw new DOMException('aborted', 'AbortError');\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexport function canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexport function makeOpts(obj = {}) {\n    return 'aborted' in obj ? { signal: obj } : obj;\n}\nexport function optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort((c0, c1) => {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif;\n    });\n    for (const chunk of chunks) {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === undefined) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    }\n    return mergedChunks;\n}\nexport function parsePseudoBin(bytes, offset) {\n    const lineCount = longToNumber(Long.fromBytesLE(Array.prototype.slice.call(bytes, offset, offset + 8), true));\n    return { lineCount };\n}\nexport function findFirstData(firstDataLine, virtualOffset) {\n    return firstDataLine\n        ? firstDataLine.compareTo(virtualOffset) > 0\n            ? virtualOffset\n            : firstDataLine\n        : virtualOffset;\n}\nexport function parseNameBytes(namesBytes, renameRefSeq = s => s) {\n    let currRefId = 0;\n    let currNameStart = 0;\n    const refIdToName = [];\n    const refNameToId = {};\n    for (let i = 0; i < namesBytes.length; i += 1) {\n        if (!namesBytes[i]) {\n            if (currNameStart < i) {\n                let refName = namesBytes.toString('utf8', currNameStart, i);\n                refName = renameRefSeq(refName);\n                refIdToName[currRefId] = refName;\n                refNameToId[refName] = currRefId;\n            }\n            currNameStart = i + 1;\n            currRefId += 1;\n        }\n    }\n    return { refNameToId, refIdToName };\n}\n//# sourceMappingURL=util.js.map","export default class IndexFile {\n    /**\n     * @param {filehandle} filehandle\n     * @param {function} [renameRefSeqs]\n     */\n    constructor({ filehandle, renameRefSeq = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeq;\n    }\n}\n//# sourceMappingURL=indexFile.js.map","import { fromBytes } from './virtualOffset';\nimport Chunk from './chunk';\nimport { optimizeChunks, parsePseudoBin, findFirstData } from './util';\nimport IndexFile from './indexFile';\nconst BAI_MAGIC = 21578050; // BAI\\1\nfunction roundDown(n, multiple) {\n    return n - (n % multiple);\n}\nfunction roundUp(n, multiple) {\n    return n - (n % multiple) + multiple;\n}\nfunction reg2bins(beg, end) {\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nexport default class BAI extends IndexFile {\n    async lineCount(refId, opts) {\n        var _a, _b;\n        const indexData = await this.parse(opts);\n        return ((_b = (_a = indexData.indices[refId]) === null || _a === void 0 ? void 0 : _a.stats) === null || _b === void 0 ? void 0 : _b.lineCount) || 0;\n    }\n    // fetch and parse the index\n    async _parse(opts) {\n        const bytes = (await this.filehandle.readFile(opts));\n        // check BAI magic numbers\n        if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n            throw new Error('Not a BAI file');\n        }\n        const refCount = bytes.readInt32LE(4);\n        const depth = 5;\n        const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        // read the indexes for each reference sequence\n        let curr = 8;\n        let firstDataLine;\n        const indices = new Array(refCount);\n        for (let i = 0; i < refCount; i++) {\n            // the binning index\n            const binCount = bytes.readInt32LE(curr);\n            let stats;\n            curr += 4;\n            const binIndex = {};\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = bytes.readUInt32LE(curr);\n                curr += 4;\n                if (bin === binLimit + 1) {\n                    curr += 4;\n                    stats = parsePseudoBin(bytes, curr + 16);\n                    curr += 32;\n                }\n                else if (bin > binLimit + 1) {\n                    throw new Error('bai index contains too many bins, please use CSI');\n                }\n                else {\n                    const chunkCount = bytes.readInt32LE(curr);\n                    curr += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k++) {\n                        const u = fromBytes(bytes, curr);\n                        curr += 8;\n                        const v = fromBytes(bytes, curr);\n                        curr += 8;\n                        firstDataLine = findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            const linearCount = bytes.readInt32LE(curr);\n            curr += 4;\n            // as we're going through the linear index, figure out the smallest\n            // virtual offset in the indexes, which tells us where the BAM header\n            // ends\n            const linearIndex = new Array(linearCount);\n            for (let j = 0; j < linearCount; j++) {\n                const offset = fromBytes(bytes, curr);\n                curr += 8;\n                firstDataLine = findFirstData(firstDataLine, offset);\n                linearIndex[j] = offset;\n            }\n            indices[i] = { binIndex, linearIndex, stats };\n        }\n        return {\n            bai: true,\n            firstDataLine,\n            maxBlockSize: 1 << 16,\n            indices,\n            refCount,\n        };\n    }\n    async indexCov(seqId, start, end, opts = {}) {\n        const v = 16384;\n        const range = start !== undefined;\n        const indexData = await this.parse(opts);\n        const seqIdx = indexData.indices[seqId];\n        if (!seqIdx) {\n            return [];\n        }\n        const { linearIndex = [], stats } = seqIdx;\n        if (linearIndex.length === 0) {\n            return [];\n        }\n        const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v);\n        const s = start === undefined ? 0 : roundDown(start, v);\n        const depths = range\n            ? new Array((e - s) / v)\n            : new Array(linearIndex.length - 1);\n        const totalSize = linearIndex[linearIndex.length - 1].blockPosition;\n        if (e > (linearIndex.length - 1) * v) {\n            throw new Error('query outside of range of linear index');\n        }\n        let currentPos = linearIndex[s / v].blockPosition;\n        for (let i = s / v, j = 0; i < e / v; i++, j++) {\n            depths[j] = {\n                score: linearIndex[i + 1].blockPosition - currentPos,\n                start: i * v,\n                end: i * v + v,\n            };\n            currentPos = linearIndex[i + 1].blockPosition;\n        }\n        return depths.map(d => ({\n            ...d,\n            score: (d.score * ((stats === null || stats === void 0 ? void 0 : stats.lineCount) || 0)) / totalSize,\n        }));\n    }\n    async blocksForRange(refId, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // List of bin #s that overlap min, max\n        const overlappingBins = reg2bins(min, max);\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (const binChunk of binChunks) {\n                        chunks.push(binChunk);\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n                lowest = vp;\n            }\n        }\n        return optimizeChunks(chunks, lowest);\n    }\n    async parse(opts = {}) {\n        if (!this.setupP) {\n            this.setupP = this._parse(opts).catch(e => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        var _a;\n        const header = await this.parse(opts);\n        return !!((_a = header.indices[seqId]) === null || _a === void 0 ? void 0 : _a.binIndex);\n    }\n}\n//# sourceMappingURL=bai.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport VirtualOffset, { fromBytes } from './virtualOffset';\nimport Chunk from './chunk';\nimport { optimizeChunks, findFirstData, parsePseudoBin, parseNameBytes, } from './util';\nimport IndexFile from './indexFile';\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nexport default class CSI extends IndexFile {\n    constructor() {\n        super(...arguments);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refId, opts) {\n        var _a, _b;\n        const indexData = await this.parse(opts);\n        return ((_b = (_a = indexData.indices[refId]) === null || _a === void 0 ? void 0 : _a.stats) === null || _b === void 0 ? void 0 : _b.lineCount) || 0;\n    }\n    async indexCov() {\n        return [];\n    }\n    parseAuxData(bytes, offset) {\n        const formatFlags = bytes.readInt32LE(offset);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: bytes.readInt32LE(offset + 4),\n            start: bytes.readInt32LE(offset + 8),\n            end: bytes.readInt32LE(offset + 12),\n        };\n        const metaValue = bytes.readInt32LE(offset + 16);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : '';\n        const skipLines = bytes.readInt32LE(offset + 20);\n        const nameSectionLength = bytes.readInt32LE(offset + 24);\n        return {\n            columnNumbers,\n            coordinateType,\n            metaValue,\n            metaChar,\n            skipLines,\n            format,\n            formatFlags,\n            ...parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength), this.renameRefSeq),\n        };\n    }\n    // fetch and parse the index\n    async _parse(opts) {\n        const buffer = await this.filehandle.readFile(opts);\n        const bytes = await unzip(buffer);\n        let csiVersion;\n        // check TBI magic numbers\n        if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n            // TODO: do we need to support big-endian CSI files?\n        }\n        this.minShift = bytes.readInt32LE(4);\n        this.depth = bytes.readInt32LE(8);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const auxLength = bytes.readInt32LE(12);\n        const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined;\n        const refCount = bytes.readInt32LE(16 + auxLength);\n        // read the indexes for each reference sequence\n        let curr = 16 + auxLength + 4;\n        let firstDataLine;\n        const indices = new Array(refCount);\n        for (let i = 0; i < refCount; i++) {\n            // the binning index\n            const binCount = bytes.readInt32LE(curr);\n            curr += 4;\n            const binIndex = {};\n            let stats; // < provided by parsing a pseudo-bin, if present\n            for (let j = 0; j < binCount; j++) {\n                const bin = bytes.readUInt32LE(curr);\n                curr += 4;\n                if (bin > this.maxBinNumber) {\n                    stats = parsePseudoBin(bytes, curr + 28);\n                    curr += 28 + 16;\n                }\n                else {\n                    firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr));\n                    curr += 8;\n                    const chunkCount = bytes.readInt32LE(curr);\n                    curr += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, curr);\n                        curr += 8;\n                        const v = fromBytes(bytes, curr);\n                        curr += 8;\n                        firstDataLine = findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            indices[i] = { binIndex, stats };\n        }\n        return {\n            csiVersion,\n            firstDataLine,\n            indices,\n            refCount,\n            csi: true,\n            maxBlockSize: 1 << 16,\n            ...aux,\n        };\n    }\n    async blocksForRange(refId, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const ba = indexData === null || indexData === void 0 ? void 0 : indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const overlappingBins = this.reg2bins(min, max);\n        if (overlappingBins.length === 0) {\n            return [];\n        }\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (const c of binChunks) {\n                        chunks.push(c);\n                    }\n                }\n            }\n        }\n        return optimizeChunks(chunks, new VirtualOffset(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end)\n     * (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n    async parse(opts = {}) {\n        if (!this.setupP) {\n            this.setupP = this._parse(opts).catch(e => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        var _a;\n        const header = await this.parse(opts);\n        return !!((_a = header.indices[seqId]) === null || _a === void 0 ? void 0 : _a.binIndex);\n    }\n}\n//# sourceMappingURL=csi.js.map","export default {\n    //  the read is paired in sequencing, no matter whether it is mapped in a pair\n    BAM_FPAIRED: 1,\n    //  the read is mapped in a proper pair\n    BAM_FPROPER_PAIR: 2,\n    //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n    BAM_FUNMAP: 4,\n    //  the mate is unmapped\n    BAM_FMUNMAP: 8,\n    //  the read is mapped to the reverse strand\n    BAM_FREVERSE: 16,\n    //  the mate is mapped to the reverse strand\n    BAM_FMREVERSE: 32,\n    //  this is read1\n    BAM_FREAD1: 64,\n    //  this is read2\n    BAM_FREAD2: 128,\n    //  not primary alignment\n    BAM_FSECONDARY: 256,\n    //  QC failure\n    BAM_FQCFAIL: 512,\n    //  optical or PCR duplicate\n    BAM_FDUP: 1024,\n    //  supplementary alignment\n    BAM_FSUPPLEMENTARY: 2048,\n};\n//# sourceMappingURL=constants.js.map","import Constants from './constants';\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('');\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('');\n/**\n * Class of each BAM record returned by this API.\n */\nexport default class BamRecord {\n    constructor(args) {\n        this.data = {};\n        this._tagList = [];\n        this._allTagsParsed = false;\n        const { bytes, fileOffset } = args;\n        const { byteArray, start } = bytes;\n        this.data = { start: byteArray.readInt32LE(start + 8) };\n        this.bytes = bytes;\n        this._id = fileOffset;\n        this._refID = byteArray.readInt32LE(start + 4);\n        this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16;\n    }\n    get(field) {\n        //@ts-ignore\n        if (this[field]) {\n            //@ts-ignore\n            if (this.data[field]) {\n                return this.data[field];\n            }\n            //@ts-ignore\n            this.data[field] = this[field]();\n            return this.data[field];\n        }\n        return this._get(field.toLowerCase());\n    }\n    end() {\n        return this.get('start') + this.get('length_on_ref');\n    }\n    seq_id() {\n        return this._refID;\n    }\n    // same as get(), except requires lower-case arguments.  used\n    // internally to save lots of calls to field.toLowerCase()\n    _get(field) {\n        if (field in this.data) {\n            return this.data[field];\n        }\n        this.data[field] = this._parseTag(field);\n        return this.data[field];\n    }\n    _tags() {\n        this._parseAllTags();\n        let tags = ['seq'];\n        if (!this.isSegmentUnmapped()) {\n            tags.push('start', 'end', 'strand', 'score', 'qual', 'MQ', 'CIGAR', 'length_on_ref', 'template_length');\n        }\n        if (this.isPaired()) {\n            tags.push('next_segment_position', 'pair_orientation');\n        }\n        tags = tags.concat(this._tagList || []);\n        for (const k of Object.keys(this.data)) {\n            if (!k.startsWith('_') && k !== 'next_seq_id') {\n                tags.push(k);\n            }\n        }\n        const seen = {};\n        return tags.filter(t => {\n            if ((t in this.data && this.data[t] === undefined) ||\n                t === 'CG' ||\n                t === 'cg') {\n                return false;\n            }\n            const lt = t.toLowerCase();\n            const s = seen[lt];\n            seen[lt] = true;\n            return !s;\n        });\n    }\n    parent() {\n        return;\n    }\n    children() {\n        return this.get('subfeatures');\n    }\n    id() {\n        return this._id;\n    }\n    // special parsers\n    /**\n     * Mapping quality score.\n     */\n    mq() {\n        const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8;\n        return mq === 255 ? undefined : mq;\n    }\n    score() {\n        return this.get('mq');\n    }\n    qual() {\n        var _a;\n        return (_a = this.qualRaw()) === null || _a === void 0 ? void 0 : _a.join(' ');\n    }\n    qualRaw() {\n        if (this.isSegmentUnmapped()) {\n            return;\n        }\n        const { start, byteArray } = this.bytes;\n        const p = start +\n            36 +\n            this.get('_l_read_name') +\n            this.get('_n_cigar_op') * 4 +\n            this.get('_seq_bytes');\n        const lseq = this.get('seq_length');\n        return byteArray.subarray(p, p + lseq);\n    }\n    strand() {\n        return this.isReverseComplemented() ? -1 : 1;\n    }\n    multi_segment_next_segment_strand() {\n        if (this.isMateUnmapped()) {\n            return;\n        }\n        return this.isMateReverseComplemented() ? -1 : 1;\n    }\n    name() {\n        return this.get('_read_name');\n    }\n    _read_name() {\n        const nl = this.get('_l_read_name');\n        const { byteArray, start } = this.bytes;\n        return byteArray.toString('ascii', start + 36, start + 36 + nl - 1);\n    }\n    /**\n     * Get the value of a tag, parsing the tags as far as necessary.\n     * Only called if we have not already parsed that field.\n     */\n    _parseTag(tagName) {\n        // if all of the tags have been parsed and we're still being\n        // called, we already know that we have no such tag, because\n        // it would already have been cached.\n        if (this._allTagsParsed) {\n            return;\n        }\n        const { byteArray, start } = this.bytes;\n        let p = this._tagOffset ||\n            start +\n                36 +\n                this.get('_l_read_name') +\n                this.get('_n_cigar_op') * 4 +\n                this.get('_seq_bytes') +\n                this.get('seq_length');\n        const blockEnd = this.bytes.end;\n        let lcTag;\n        while (p < blockEnd && lcTag !== tagName) {\n            const tag = String.fromCharCode(byteArray[p], byteArray[p + 1]);\n            lcTag = tag.toLowerCase();\n            const type = String.fromCharCode(byteArray[p + 2]);\n            p += 3;\n            let value;\n            switch (type) {\n                case 'A': {\n                    value = String.fromCharCode(byteArray[p]);\n                    p += 1;\n                    break;\n                }\n                case 'i': {\n                    value = byteArray.readInt32LE(p);\n                    p += 4;\n                    break;\n                }\n                case 'I': {\n                    value = byteArray.readUInt32LE(p);\n                    p += 4;\n                    break;\n                }\n                case 'c': {\n                    value = byteArray.readInt8(p);\n                    p += 1;\n                    break;\n                }\n                case 'C': {\n                    value = byteArray.readUInt8(p);\n                    p += 1;\n                    break;\n                }\n                case 's': {\n                    value = byteArray.readInt16LE(p);\n                    p += 2;\n                    break;\n                }\n                case 'S': {\n                    value = byteArray.readUInt16LE(p);\n                    p += 2;\n                    break;\n                }\n                case 'f': {\n                    value = byteArray.readFloatLE(p);\n                    p += 4;\n                    break;\n                }\n                case 'Z':\n                case 'H': {\n                    value = '';\n                    while (p <= blockEnd) {\n                        const cc = byteArray[p++];\n                        if (cc === 0) {\n                            break;\n                        }\n                        else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                    break;\n                }\n                case 'B': {\n                    value = '';\n                    const cc = byteArray[p++];\n                    const Btype = String.fromCharCode(cc);\n                    const limit = byteArray.readInt32LE(p);\n                    p += 4;\n                    if (Btype === 'i') {\n                        if (tag === 'CG') {\n                            for (let k = 0; k < limit; k++) {\n                                const cigop = byteArray.readInt32LE(p);\n                                const lop = cigop >> 4;\n                                const op = CIGAR_DECODER[cigop & 0xf];\n                                value += lop + op;\n                                p += 4;\n                            }\n                        }\n                        else {\n                            for (let k = 0; k < limit; k++) {\n                                value += byteArray.readInt32LE(p);\n                                if (k + 1 < limit) {\n                                    value += ',';\n                                }\n                                p += 4;\n                            }\n                        }\n                    }\n                    if (Btype === 'I') {\n                        if (tag === 'CG') {\n                            for (let k = 0; k < limit; k++) {\n                                const cigop = byteArray.readUInt32LE(p);\n                                const lop = cigop >> 4;\n                                const op = CIGAR_DECODER[cigop & 0xf];\n                                value += lop + op;\n                                p += 4;\n                            }\n                        }\n                        else {\n                            for (let k = 0; k < limit; k++) {\n                                value += byteArray.readUInt32LE(p);\n                                if (k + 1 < limit) {\n                                    value += ',';\n                                }\n                                p += 4;\n                            }\n                        }\n                    }\n                    if (Btype === 's') {\n                        for (let k = 0; k < limit; k++) {\n                            value += byteArray.readInt16LE(p);\n                            if (k + 1 < limit) {\n                                value += ',';\n                            }\n                            p += 2;\n                        }\n                    }\n                    if (Btype === 'S') {\n                        for (let k = 0; k < limit; k++) {\n                            value += byteArray.readUInt16LE(p);\n                            if (k + 1 < limit) {\n                                value += ',';\n                            }\n                            p += 2;\n                        }\n                    }\n                    if (Btype === 'c') {\n                        for (let k = 0; k < limit; k++) {\n                            value += byteArray.readInt8(p);\n                            if (k + 1 < limit) {\n                                value += ',';\n                            }\n                            p += 1;\n                        }\n                    }\n                    if (Btype === 'C') {\n                        for (let k = 0; k < limit; k++) {\n                            value += byteArray.readUInt8(p);\n                            if (k + 1 < limit) {\n                                value += ',';\n                            }\n                            p += 1;\n                        }\n                    }\n                    if (Btype === 'f') {\n                        for (let k = 0; k < limit; k++) {\n                            value += byteArray.readFloatLE(p);\n                            if (k + 1 < limit) {\n                                value += ',';\n                            }\n                            p += 4;\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`);\n                    value = undefined;\n                    p = blockEnd;\n                } // stop parsing tags\n            }\n            this._tagOffset = p;\n            this._tagList.push(tag);\n            if (lcTag === tagName) {\n                return value;\n            }\n            this.data[lcTag] = value;\n        }\n        this._allTagsParsed = true;\n        return;\n    }\n    _parseAllTags() {\n        this._parseTag('');\n    }\n    _parseCigar(cigar) {\n        return (\n        //@ts-ignore\n        cigar\n            .match(/\\d+\\D/g)\n            //@ts-ignore\n            .map(op => [/\\D/.exec(op)[0].toUpperCase(), Number.parseInt(op, 10)]));\n    }\n    /**\n     * @returns {boolean} true if the read is paired, regardless of whether both\n     * segments are mapped\n     */\n    isPaired() {\n        return !!(this.flags & Constants.BAM_FPAIRED);\n    }\n    /** @returns {boolean} true if the read is paired, and both segments are mapped */\n    isProperlyPaired() {\n        return !!(this.flags & Constants.BAM_FPROPER_PAIR);\n    }\n    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n    isSegmentUnmapped() {\n        return !!(this.flags & Constants.BAM_FUNMAP);\n    }\n    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n    isMateUnmapped() {\n        return !!(this.flags & Constants.BAM_FMUNMAP);\n    }\n    /** @returns {boolean} true if the read is mapped to the reverse strand */\n    isReverseComplemented() {\n        return !!(this.flags & Constants.BAM_FREVERSE);\n    }\n    /** @returns {boolean} true if the mate is mapped to the reverse strand */\n    isMateReverseComplemented() {\n        return !!(this.flags & Constants.BAM_FMREVERSE);\n    }\n    /** @returns {boolean} true if this is read number 1 in a pair */\n    isRead1() {\n        return !!(this.flags & Constants.BAM_FREAD1);\n    }\n    /** @returns {boolean} true if this is read number 2 in a pair */\n    isRead2() {\n        return !!(this.flags & Constants.BAM_FREAD2);\n    }\n    /** @returns {boolean} true if this is a secondary alignment */\n    isSecondary() {\n        return !!(this.flags & Constants.BAM_FSECONDARY);\n    }\n    /** @returns {boolean} true if this read has failed QC checks */\n    isFailedQc() {\n        return !!(this.flags & Constants.BAM_FQCFAIL);\n    }\n    /** @returns {boolean} true if the read is an optical or PCR duplicate */\n    isDuplicate() {\n        return !!(this.flags & Constants.BAM_FDUP);\n    }\n    /** @returns {boolean} true if this is a supplementary alignment */\n    isSupplementary() {\n        return !!(this.flags & Constants.BAM_FSUPPLEMENTARY);\n    }\n    cigar() {\n        if (this.isSegmentUnmapped()) {\n            return;\n        }\n        const { byteArray, start } = this.bytes;\n        const numCigarOps = this.get('_n_cigar_op');\n        let p = start + 36 + this.get('_l_read_name');\n        const seqLen = this.get('seq_length');\n        let cigar = '';\n        let lref = 0;\n        // check for CG tag by inspecting whether the CIGAR field\n        // contains a clip that consumes entire seqLen\n        let cigop = byteArray.readInt32LE(p);\n        let lop = cigop >> 4;\n        let op = CIGAR_DECODER[cigop & 0xf];\n        if (op === 'S' && lop === seqLen) {\n            // if there is a CG the second CIGAR field will\n            // be a N tag the represents the length on ref\n            p += 4;\n            cigop = byteArray.readInt32LE(p);\n            lop = cigop >> 4;\n            op = CIGAR_DECODER[cigop & 0xf];\n            if (op !== 'N') {\n                console.warn('CG tag with no N tag');\n            }\n            this.data.length_on_ref = lop;\n            return this.get('CG');\n        }\n        else {\n            for (let c = 0; c < numCigarOps; ++c) {\n                cigop = byteArray.readInt32LE(p);\n                lop = cigop >> 4;\n                op = CIGAR_DECODER[cigop & 0xf];\n                cigar += lop + op;\n                // soft clip, hard clip, and insertion don't count toward\n                // the length on the reference\n                if (op !== 'H' && op !== 'S' && op !== 'I') {\n                    lref += lop;\n                }\n                p += 4;\n            }\n            this.data.length_on_ref = lref;\n            return cigar;\n        }\n    }\n    length_on_ref() {\n        if (this.data.length_on_ref) {\n            return this.data.length_on_ref;\n        }\n        else {\n            this.get('cigar'); // the length_on_ref is set as a side effect\n            return this.data.length_on_ref;\n        }\n    }\n    _n_cigar_op() {\n        return this.get('_flag_nc') & 0xffff;\n    }\n    _l_read_name() {\n        return this.get('_bin_mq_nl') & 0xff;\n    }\n    /**\n     * number of bytes in the sequence field\n     */\n    _seq_bytes() {\n        return (this.get('seq_length') + 1) >> 1;\n    }\n    getReadBases() {\n        return this.seq();\n    }\n    seq() {\n        const { byteArray, start } = this.bytes;\n        const p = start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4;\n        const seqBytes = this.get('_seq_bytes');\n        const len = this.get('seq_length');\n        let buf = '';\n        let i = 0;\n        for (let j = 0; j < seqBytes; ++j) {\n            const sb = byteArray[p + j];\n            buf += SEQRET_DECODER[(sb & 0xf0) >> 4];\n            i++;\n            if (i < len) {\n                buf += SEQRET_DECODER[sb & 0x0f];\n                i++;\n            }\n        }\n        return buf;\n    }\n    // adapted from igv.js\n    getPairOrientation() {\n        if (!this.isSegmentUnmapped() &&\n            !this.isMateUnmapped() &&\n            this._refID === this._next_refid()) {\n            const s1 = this.isReverseComplemented() ? 'R' : 'F';\n            const s2 = this.isMateReverseComplemented() ? 'R' : 'F';\n            let o1 = ' ';\n            let o2 = ' ';\n            if (this.isRead1()) {\n                o1 = '1';\n                o2 = '2';\n            }\n            else if (this.isRead2()) {\n                o1 = '2';\n                o2 = '1';\n            }\n            const tmp = [];\n            const isize = this.template_length();\n            if (isize > 0) {\n                tmp[0] = s1;\n                tmp[1] = o1;\n                tmp[2] = s2;\n                tmp[3] = o2;\n            }\n            else {\n                tmp[2] = s1;\n                tmp[3] = o1;\n                tmp[0] = s2;\n                tmp[1] = o2;\n            }\n            return tmp.join('');\n        }\n        return '';\n    }\n    _bin_mq_nl() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 12);\n    }\n    _flag_nc() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 16);\n    }\n    seq_length() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 20);\n    }\n    _next_refid() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 24);\n    }\n    _next_pos() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 28);\n    }\n    template_length() {\n        return this.bytes.byteArray.readInt32LE(this.bytes.start + 32);\n    }\n    toJSON() {\n        const data = {};\n        for (const k of Object.keys(this)) {\n            if (k.startsWith('_') || k === 'bytes') {\n                continue;\n            }\n            //@ts-ignore\n            data[k] = this[k];\n        }\n        return data;\n    }\n}\n//# sourceMappingURL=record.js.map","export function parseHeaderText(text) {\n    const lines = text.split(/\\r?\\n/);\n    const data = [];\n    for (const line of lines) {\n        const [tag, ...fields] = line.split(/\\t/);\n        if (tag) {\n            data.push({\n                tag: tag.slice(1),\n                data: fields.map(f => {\n                    const r = f.indexOf(':');\n                    const fieldTag = f.slice(0, r);\n                    const value = f.slice(r + 1);\n                    return { tag: fieldTag, value };\n                }),\n            });\n        }\n    }\n    return data;\n}\n//# sourceMappingURL=sam.js.map","import { Buffer } from 'buffer';\nimport crc32 from 'crc/crc32';\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle';\nimport { LocalFile, RemoteFile } from 'generic-filehandle';\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from 'quick-lru';\n// locals\nimport BAI from './bai';\nimport CSI from './csi';\nimport BAMFeature from './record';\nimport { parseHeaderText } from './sam';\nimport { checkAbortSignal, timeout, makeOpts } from './util';\nexport const BAM_MAGIC = 21840194;\nconst blockLen = 1 << 16;\nasync function gen2array(gen) {\n    let out = [];\n    for await (const x of gen) {\n        out = out.concat(x);\n    }\n    return out;\n}\nclass NullFilehandle {\n    read() {\n        throw new Error('never called');\n    }\n    stat() {\n        throw new Error('never called');\n    }\n    readFile() {\n        throw new Error('never called');\n    }\n    close() {\n        throw new Error('never called');\n    }\n}\nexport default class BamFile {\n    constructor({ bamFilehandle, bamPath, bamUrl, baiPath, baiFilehandle, baiUrl, csiPath, csiFilehandle, csiUrl, htsget, yieldThreadTime = 100, renameRefSeqs = n => n, }) {\n        this.htsget = false;\n        this.featureCache = new AbortablePromiseCache({\n            cache: new QuickLRU({\n                maxSize: 50,\n            }),\n            fill: async (args, signal) => {\n                const { chunk, opts } = args;\n                const { data, cpositions, dpositions } = await this._readChunk({\n                    chunk,\n                    opts: { ...opts, signal },\n                });\n                return this.readBamFeatures(data, cpositions, dpositions, chunk);\n            },\n        });\n        this.renameRefSeq = renameRefSeqs;\n        if (bamFilehandle) {\n            this.bam = bamFilehandle;\n        }\n        else if (bamPath) {\n            this.bam = new LocalFile(bamPath);\n        }\n        else if (bamUrl) {\n            this.bam = new RemoteFile(bamUrl);\n        }\n        else if (htsget) {\n            this.htsget = true;\n            this.bam = new NullFilehandle();\n        }\n        else {\n            throw new Error('unable to initialize bam');\n        }\n        if (csiFilehandle) {\n            this.index = new CSI({ filehandle: csiFilehandle });\n        }\n        else if (csiPath) {\n            this.index = new CSI({ filehandle: new LocalFile(csiPath) });\n        }\n        else if (csiUrl) {\n            this.index = new CSI({ filehandle: new RemoteFile(csiUrl) });\n        }\n        else if (baiFilehandle) {\n            this.index = new BAI({ filehandle: baiFilehandle });\n        }\n        else if (baiPath) {\n            this.index = new BAI({ filehandle: new LocalFile(baiPath) });\n        }\n        else if (baiUrl) {\n            this.index = new BAI({ filehandle: new RemoteFile(baiUrl) });\n        }\n        else if (bamPath) {\n            this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) });\n        }\n        else if (bamUrl) {\n            this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) });\n        }\n        else if (htsget) {\n            this.htsget = true;\n        }\n        else {\n            throw new Error('unable to infer index format');\n        }\n        this.yieldThreadTime = yieldThreadTime;\n    }\n    async getHeaderPre(origOpts) {\n        const opts = makeOpts(origOpts);\n        if (!this.index) {\n            return;\n        }\n        const indexData = await this.index.parse(opts);\n        const ret = indexData.firstDataLine\n            ? indexData.firstDataLine.blockPosition + 65535\n            : undefined;\n        let buffer;\n        if (ret) {\n            const s = ret + blockLen;\n            const res = await this.bam.read(Buffer.alloc(s), 0, s, 0, opts);\n            if (!res.bytesRead) {\n                throw new Error('Error reading header');\n            }\n            buffer = res.buffer.subarray(0, Math.min(res.bytesRead, ret));\n        }\n        else {\n            buffer = await this.bam.readFile(opts);\n        }\n        const uncba = await unzip(buffer);\n        if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n            throw new Error('Not a BAM file');\n        }\n        const headLen = uncba.readInt32LE(4);\n        this.header = uncba.toString('utf8', 8, 8 + headLen);\n        const { chrToIndex, indexToChr } = await this._readRefSeqs(headLen + 8, 65535, opts);\n        this.chrToIndex = chrToIndex;\n        this.indexToChr = indexToChr;\n        return parseHeaderText(this.header);\n    }\n    getHeader(opts) {\n        if (!this.headerP) {\n            this.headerP = this.getHeaderPre(opts).catch(e => {\n                this.headerP = undefined;\n                throw e;\n            });\n        }\n        return this.headerP;\n    }\n    async getHeaderText(opts = {}) {\n        await this.getHeader(opts);\n        return this.header;\n    }\n    // the full length of the refseq block is not given in advance so this grabs\n    // a chunk and doubles it if all refseqs haven't been processed\n    async _readRefSeqs(start, refSeqBytes, opts) {\n        if (start > refSeqBytes) {\n            return this._readRefSeqs(start, refSeqBytes * 2, opts);\n        }\n        const size = refSeqBytes + blockLen;\n        const { bytesRead, buffer } = await this.bam.read(Buffer.alloc(size), 0, refSeqBytes, 0, opts);\n        if (!bytesRead) {\n            throw new Error('Error reading refseqs from header');\n        }\n        const uncba = await unzip(buffer.subarray(0, Math.min(bytesRead, refSeqBytes)));\n        const nRef = uncba.readInt32LE(start);\n        let p = start + 4;\n        const chrToIndex = {};\n        const indexToChr = [];\n        for (let i = 0; i < nRef; i += 1) {\n            const lName = uncba.readInt32LE(p);\n            const refName = this.renameRefSeq(uncba.toString('utf8', p + 4, p + 4 + lName - 1));\n            const lRef = uncba.readInt32LE(p + lName + 4);\n            chrToIndex[refName] = i;\n            indexToChr.push({ refName, length: lRef });\n            p = p + 8 + lName;\n            if (p > uncba.length) {\n                console.warn(`BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`);\n                return this._readRefSeqs(start, refSeqBytes * 2, opts);\n            }\n        }\n        return { chrToIndex, indexToChr };\n    }\n    async getRecordsForRange(chr, min, max, opts) {\n        return gen2array(this.streamRecordsForRange(chr, min, max, opts));\n    }\n    async *streamRecordsForRange(chr, min, max, opts) {\n        var _a;\n        await this.getHeader(opts);\n        const chrId = (_a = this.chrToIndex) === null || _a === void 0 ? void 0 : _a[chr];\n        if (chrId === undefined || !this.index) {\n            yield [];\n        }\n        else {\n            const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts);\n            yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts);\n        }\n    }\n    async *_fetchChunkFeatures(chunks, chrId, min, max, opts = {}) {\n        const { viewAsPairs } = opts;\n        const feats = [];\n        let done = false;\n        for (const chunk of chunks) {\n            const records = await this.featureCache.get(chunk.toString(), { chunk, opts }, opts.signal);\n            const recs = [];\n            for (const feature of records) {\n                if (feature.seq_id() === chrId) {\n                    if (feature.get('start') >= max) {\n                        // past end of range, can stop iterating\n                        done = true;\n                        break;\n                    }\n                    else if (feature.get('end') >= min) {\n                        // must be in range\n                        recs.push(feature);\n                    }\n                }\n            }\n            feats.push(recs);\n            yield recs;\n            if (done) {\n                break;\n            }\n        }\n        checkAbortSignal(opts.signal);\n        if (viewAsPairs) {\n            yield this.fetchPairs(chrId, feats, opts);\n        }\n    }\n    async fetchPairs(chrId, feats, opts) {\n        const { pairAcrossChr, maxInsertSize = 200000 } = opts;\n        const unmatedPairs = {};\n        const readIds = {};\n        feats.map(ret => {\n            const readNames = {};\n            for (const element of ret) {\n                const name = element.name();\n                const id = element.id();\n                if (!readNames[name]) {\n                    readNames[name] = 0;\n                }\n                readNames[name]++;\n                readIds[id] = 1;\n            }\n            for (const [k, v] of Object.entries(readNames)) {\n                if (v === 1) {\n                    unmatedPairs[k] = true;\n                }\n            }\n        });\n        const matePromises = [];\n        feats.map(ret => {\n            for (const f of ret) {\n                const name = f.name();\n                const start = f.get('start');\n                const pnext = f._next_pos();\n                const rnext = f._next_refid();\n                if (this.index &&\n                    unmatedPairs[name] &&\n                    (pairAcrossChr ||\n                        (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))) {\n                    matePromises.push(this.index.blocksForRange(rnext, pnext, pnext + 1, opts));\n                }\n            }\n        });\n        // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n        // concatenated, then filter dup chunks)\n        const map = new Map();\n        const res = await Promise.all(matePromises);\n        for (const m of res.flat()) {\n            if (!map.has(m.toString())) {\n                map.set(m.toString(), m);\n            }\n        }\n        const mateFeatPromises = await Promise.all([...map.values()].map(async (c) => {\n            const { data, cpositions, dpositions, chunk } = await this._readChunk({\n                chunk: c,\n                opts,\n            });\n            const mateRecs = [];\n            for (const feature of await this.readBamFeatures(data, cpositions, dpositions, chunk)) {\n                if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {\n                    mateRecs.push(feature);\n                }\n            }\n            return mateRecs;\n        }));\n        return mateFeatPromises.flat();\n    }\n    async _readRegion(position, size, opts = {}) {\n        const { bytesRead, buffer } = await this.bam.read(Buffer.alloc(size), 0, size, position, opts);\n        return buffer.subarray(0, Math.min(bytesRead, size));\n    }\n    async _readChunk({ chunk, opts }) {\n        const buffer = await this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);\n        const { buffer: data, cpositions, dpositions, } = await unzipChunkSlice(buffer, chunk);\n        return { data, cpositions, dpositions, chunk };\n    }\n    async readBamFeatures(ba, cpositions, dpositions, chunk) {\n        let blockStart = 0;\n        const sink = [];\n        let pos = 0;\n        let last = +Date.now();\n        while (blockStart + 4 < ba.length) {\n            const blockSize = ba.readInt32LE(blockStart);\n            const blockEnd = blockStart + 4 + blockSize - 1;\n            // increment position to the current decompressed status\n            if (dpositions) {\n                while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) { }\n                pos--;\n            }\n            // only try to read the feature if we have all the bytes for it\n            if (blockEnd < ba.length) {\n                const feature = new BAMFeature({\n                    bytes: {\n                        byteArray: ba,\n                        start: blockStart,\n                        end: blockEnd,\n                    },\n                    // the below results in an automatically calculated file-offset based\n                    // ID if the info for that is available, otherwise crc32 of the\n                    // features\n                    //\n                    // cpositions[pos] refers to actual file offset of a bgzip block\n                    // boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a\n                    // \"unique\" address space so that data in that block could never\n                    // overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset from\n                    // that bgzip block boundary, and since the cpositions are multiplied\n                    // by (1 << 8) these uncompressed offsets get a unique space\n                    //\n                    // this has an extra chunk.minv.dataPosition added on because it\n                    // blockStart starts at 0 instead of chunk.minv.dataPosition\n                    //\n                    // the +1 is just to avoid any possible uniqueId 0 but this does not\n                    // realistically happen\n                    fileOffset: cpositions.length > 0\n                        ? cpositions[pos] * (1 << 8) +\n                            (blockStart - dpositions[pos]) +\n                            chunk.minv.dataPosition +\n                            1\n                        : // must be slice, not subarray for buffer polyfill on web\n                            crc32.signed(ba.slice(blockStart, blockEnd)),\n                });\n                sink.push(feature);\n                if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n                    await timeout(1);\n                    last = +Date.now();\n                }\n            }\n            blockStart = blockEnd + 1;\n        }\n        return sink;\n    }\n    async hasRefSeq(seqName) {\n        var _a, _b;\n        const seqId = (_a = this.chrToIndex) === null || _a === void 0 ? void 0 : _a[seqName];\n        return seqId === undefined ? false : (_b = this.index) === null || _b === void 0 ? void 0 : _b.hasRefSeq(seqId);\n    }\n    async lineCount(seqName) {\n        var _a;\n        const seqId = (_a = this.chrToIndex) === null || _a === void 0 ? void 0 : _a[seqName];\n        return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId);\n    }\n    async indexCov(seqName, start, end) {\n        var _a;\n        if (!this.index) {\n            return [];\n        }\n        await this.index.parse();\n        const seqId = (_a = this.chrToIndex) === null || _a === void 0 ? void 0 : _a[seqName];\n        return seqId === undefined ? [] : this.index.indexCov(seqId, start, end);\n    }\n    async blocksForRange(seqName, start, end, opts) {\n        var _a;\n        if (!this.index) {\n            return [];\n        }\n        await this.index.parse();\n        const seqId = (_a = this.chrToIndex) === null || _a === void 0 ? void 0 : _a[seqName];\n        return seqId === undefined\n            ? []\n            : this.index.blocksForRange(seqId, start, end, opts);\n    }\n}\n//# sourceMappingURL=bamFile.js.map","// locals\nimport { getClip, getMismatches } from '../MismatchParser';\nexport default class BamSlightlyLazyFeature {\n    // uses parameter properties to automatically create fields on the class\n    // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n    constructor(record, adapter, ref) {\n        this.record = record;\n        this.adapter = adapter;\n        this.ref = ref;\n    }\n    _get_name() {\n        return this.record.get('name');\n    }\n    _get_type() {\n        return 'match';\n    }\n    _get_score() {\n        return this.record.get('mq');\n    }\n    _get_flags() {\n        return this.record.flags;\n    }\n    _get_strand() {\n        return this.record.isReverseComplemented() ? -1 : 1;\n    }\n    _get_pair_orientation() {\n        return this.record.isPaired() ? this.record.getPairOrientation() : undefined;\n    }\n    _get_next_ref() {\n        return this.record.isPaired()\n            ? this.adapter.refIdToName(this.record._next_refid())\n            : undefined;\n    }\n    _get_next_pos() {\n        return this.record.isPaired() ? this.record._next_pos() : undefined;\n    }\n    _get_next_segment_position() {\n        return this.record.isPaired()\n            ? `${this.adapter.refIdToName(this.record._next_refid())}:${this.record._next_pos() + 1}`\n            : undefined;\n    }\n    _get_seq() {\n        return this.record.getReadBases();\n    }\n    qualRaw() {\n        return this.record.qualRaw();\n    }\n    set() { }\n    tags() {\n        const properties = Object.getOwnPropertyNames(BamSlightlyLazyFeature.prototype);\n        return [\n            ...new Set(properties\n                .filter(prop => prop.startsWith('_get_') &&\n                prop !== '_get_mismatches' &&\n                prop !== '_get_tags')\n                .map(methodName => methodName.replace('_get_', ''))\n                .concat(this.record._tags())),\n        ];\n    }\n    id() {\n        return `${this.adapter.id}-${this.record.id()}`;\n    }\n    get(field) {\n        const methodName = `_get_${field}`;\n        // @ts-expect-error\n        if (this[methodName]) {\n            // @ts-expect-error\n            return this[methodName]();\n        }\n        return this.record.get(field);\n    }\n    _get_refName() {\n        return this.adapter.refIdToName(this.record.seq_id());\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    pairedFeature() {\n        return false;\n    }\n    toJSON() {\n        return {\n            ...Object.fromEntries(this.tags()\n                .map(t => [t, this.get(t)])\n                .filter(elt => elt[1] !== undefined)),\n            uniqueId: this.id(),\n        };\n    }\n    _get_mismatches() {\n        return getMismatches(this.get('CIGAR'), this.get('MD'), this.get('seq'), this.ref, this.qualRaw());\n    }\n    _get_clipPos() {\n        const cigar = this.get('CIGAR') || '';\n        return getClip(cigar, this.get('strand'));\n    }\n}\n","import { BamFile } from '@gmod/bam';\nimport { BaseFeatureDataAdapter, } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { bytesForRegions, updateStatus } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { firstValueFrom } from 'rxjs';\n// locals\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature';\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n    // derived classes may not use the same configuration so a custom configure\n    // method allows derived classes to override this behavior\n    async configurePre() {\n        const bamLocation = this.getConf('bamLocation');\n        const location = this.getConf(['index', 'location']);\n        const indexType = this.getConf(['index', 'indexType']);\n        const pm = this.pluginManager;\n        const csi = indexType === 'CSI';\n        const bam = new BamFile({\n            bamFilehandle: openLocation(bamLocation, pm),\n            csiFilehandle: csi ? openLocation(location, pm) : undefined,\n            baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n            yieldThreadTime: Number.POSITIVE_INFINITY,\n        });\n        const adapterConfig = this.getConf('sequenceAdapter');\n        if (adapterConfig && this.getSubAdapter) {\n            const { dataAdapter } = await this.getSubAdapter(adapterConfig);\n            return {\n                bam,\n                sequenceAdapter: dataAdapter,\n            };\n        }\n        return { bam };\n    }\n    async configure() {\n        if (!this.configureP) {\n            this.configureP = this.configurePre().catch((e) => {\n                this.configureP = undefined;\n                throw e;\n            });\n        }\n        return this.configureP;\n    }\n    async getHeader(opts) {\n        const { bam } = await this.configure();\n        return bam.getHeaderText(opts);\n    }\n    async setupPre(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const { bam } = await this.configure();\n        this.samHeader = await updateStatus('Downloading index', statusCallback, async () => {\n            const samHeader = await bam.getHeader(opts);\n            // use the @SQ lines in the header to figure out the\n            // mapping between ref ref ID numbers and names\n            const idToName = [];\n            const nameToId = {};\n            samHeader === null || samHeader === void 0 ? void 0 : samHeader.filter(l => l.tag === 'SQ').forEach((sqLine, refId) => {\n                const SN = sqLine.data.find(item => item.tag === 'SN');\n                if (SN) {\n                    // this is the ref name\n                    const refName = SN.value;\n                    nameToId[refName] = refId;\n                    idToName[refId] = refName;\n                }\n            });\n            return { idToName, nameToId };\n        });\n        return this.samHeader;\n    }\n    async setup(opts) {\n        if (!this.setupP) {\n            this.setupP = this.setupPre(opts).catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames(opts) {\n        const { idToName } = await this.setup(opts);\n        return idToName;\n    }\n    async seqFetch(refName, start, end) {\n        const { sequenceAdapter } = await this.configure();\n        const refSeqStore = sequenceAdapter;\n        if (!refSeqStore) {\n            return undefined;\n        }\n        if (!refName) {\n            return undefined;\n        }\n        const features = refSeqStore.getFeatures({\n            refName,\n            start,\n            end,\n            assemblyName: '',\n        });\n        const seqChunks = await firstValueFrom(features.pipe(toArray()));\n        let sequence = '';\n        seqChunks\n            .sort((a, b) => a.get('start') - b.get('start'))\n            .forEach(chunk => {\n            const chunkStart = chunk.get('start');\n            const chunkEnd = chunk.get('end');\n            const trimStart = Math.max(start - chunkStart, 0);\n            const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);\n            const trimLength = trimEnd - trimStart;\n            const chunkSeq = chunk.get('seq') || chunk.get('residues');\n            sequence += chunkSeq.slice(trimStart, trimStart + trimLength);\n        });\n        if (sequence.length !== end - start) {\n            throw new Error(`sequence fetch failed: fetching ${refName}:${(start - 1).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(end - start).toLocaleString()}`);\n        }\n        return sequence;\n    }\n    getFeatures(region, opts) {\n        const { refName, start, end, originalRefName } = region;\n        const { signal, filterBy, statusCallback = () => { } } = opts || {};\n        return ObservableCreate(async (observer) => {\n            const { bam } = await this.configure();\n            await this.setup(opts);\n            const records = await updateStatus('Downloading alignments', statusCallback, () => bam.getRecordsForRange(refName, start, end, opts));\n            await updateStatus('Processing alignments', statusCallback, async () => {\n                const { flagInclude = 0, flagExclude = 0, tagFilter, readName, } = filterBy || {};\n                for (const record of records) {\n                    let ref;\n                    if (!record.get('MD')) {\n                        ref = await this.seqFetch(originalRefName || refName, record.get('start'), record.get('end'));\n                    }\n                    const flags = record.flags;\n                    if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n                        continue;\n                    }\n                    if (tagFilter) {\n                        const readVal = record.get(tagFilter.tag);\n                        const filterVal = tagFilter.value;\n                        if (filterVal === '*'\n                            ? readVal !== undefined\n                            : `${readVal}` !== `${filterVal}`) {\n                            continue;\n                        }\n                    }\n                    if (readName && record.get('name') !== readName) {\n                        continue;\n                    }\n                    observer.next(new BamSlightlyLazyFeature(record, this, ref));\n                }\n                observer.complete();\n            });\n        }, signal);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { bam } = await this.configure();\n        // this is a method to avoid calling on htsget adapters\n        if (bam.index) {\n            const bytes = await bytesForRegions(regions, bam);\n            const fetchSizeLimit = this.getConf('fetchSizeLimit');\n            return { bytes, fetchSizeLimit };\n        }\n        return super.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    freeResources( /* { region } */) { }\n    // depends on setup being called before the BAM constructor\n    refIdToName(refId) {\n        var _a;\n        return (_a = this.samHeader) === null || _a === void 0 ? void 0 : _a.idToName[refId];\n    }\n}\n"],"names":["VirtualOffset","blockPosition","dataPosition","b","args","min","i","fromBytes","bytes","offset","bigendian","Chunk","minv","maxv","bin","_fetchedSize","timeout","ms","resolve","longToNumber","long","checkAbortSignal","signal","canMergeBlocks","chunk1","chunk2","makeOpts","obj","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","c0","c1","dif","chunk","parsePseudoBin","Long","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","renameRefSeq","s","currRefId","currNameStart","refIdToName","refNameToId","refName","IndexFile","filehandle","BAI_MAGIC","roundDown","n","multiple","roundUp","reg2bins","beg","end","BAI","refId","opts","_a","_b","refCount","binLimit","curr","indices","binCount","stats","binIndex","j","chunkCount","k","u","v","linearCount","linearIndex","seqId","start","range","seqIdx","e","depths","totalSize","currentPos","d","max","indexData","ba","overlappingBins","binChunks","binChunk","nintv","minLin","maxLin","vp","CSI1_MAGIC","CSI2_MAGIC","lshift","num","bits","rshift","CSI","formatFlags","coordinateType","format","columnNumbers","metaValue","metaChar","skipLines","nameSectionLength","buffer","unzip","csiVersion","auxLength","aux","c","l","t","bins","Constants","SEQRET_DECODER","CIGAR_DECODER","BamRecord","fileOffset","byteArray","field","tags","seen","lt","mq","p","lseq","nl","tagName","blockEnd","lcTag","tag","type","value","cc","Btype","limit","cigop","lop","op","cigar","numCigarOps","seqLen","lref","seqBytes","len","buf","sb","s1","s2","o1","o2","tmp","data","parseHeaderText","text","lines","line","fields","f","r","fieldTag","BAM_MAGIC","blockLen","gen2array","gen","out","x","NullFilehandle","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","yieldThreadTime","renameRefSeqs","AbortablePromiseCache","QuickLRU","cpositions","dpositions","LocalFile","RemoteFile","origOpts","ret","res","Buffer","uncba","headLen","chrToIndex","indexToChr","refSeqBytes","size","bytesRead","nRef","lName","lRef","chr","chrId","viewAsPairs","feats","done","records","recs","feature","pairAcrossChr","maxInsertSize","unmatedPairs","readIds","readNames","element","name","id","matePromises","pnext","rnext","map","m","mateRecs","position","unzipChunkSlice","blockStart","sink","pos","last","blockSize","BAMFeature","crc32","seqName","BamSlightlyLazyFeature","record","adapter","ref","properties","prop","methodName","elt","getMismatches","getClip","BamAdapter","BaseFeatureDataAdapter","bamLocation","location","indexType","pm","csi","bam","openLocation","adapterConfig","dataAdapter","statusCallback","updateStatus","samHeader","idToName","nameToId","sqLine","SN","item","sequenceAdapter","refSeqStore","features","seqChunks","firstValueFrom","toArray","sequence","a","chunkStart","chunkEnd","trimStart","trimLength","chunkSeq","region","originalRefName","filterBy","ObservableCreate","observer","flagInclude","flagExclude","tagFilter","readName","flags","readVal","filterVal","regions","bytesForRegions","fetchSizeLimit"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}